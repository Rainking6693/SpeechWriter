import { Handler } from '@netlify/functions';
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import { eq, and, desc } from 'drizzle-orm';
import { 
  userPreferences, 
  contentComplianceFlags, 
  exportComplianceRecords, 
  JurisdictionType, 
  EthicsMode 
} from '@speechwriter/database';

// Database connection
const connectionString = process.env.DATABASE_URL;
if (!connectionString) {
  throw new Error('DATABASE_URL environment variable is required');
}

const sql = postgres(connectionString);
const db = drizzle(sql);

interface ExportRequest {
  speechId: string;
  exportType: 'pdf' | 'docx' | 'txt';
  acknowledgedFlags?: string[];
  forceExport?: boolean;
}

interface ComplianceCheck {
  passed: boolean;
  flags: Array<{
    id: string;
    type: string;
    reason: string;
    description: string;
    severity: string;
    acknowledged: boolean;
  }>;
  disclaimerRequired: boolean;
  disclaimerText: string;
  academicHonestyRequired: boolean;
  politicalWarningsRequired: boolean;
}

// Generate jurisdiction-specific disclaimer text
function generateDisclaimer(jurisdiction: JurisdictionType, ethicsMode: EthicsMode, speechTitle: string): string {
  const timestamp = new Date().toISOString().split('T')[0];
  let disclaimer = `\n\n--- AI GENERATION DISCLAIMER ---\n`;
  
  disclaimer += `This speech was created with AI assistance on ${timestamp}.\n`;
  
  // Jurisdiction-specific disclaimers
  switch (jurisdiction) {
    case 'EU':
      disclaimer += `\nEuropean Union Compliance:\n`;
      disclaimer += `- This content was generated in compliance with EU AI regulations\n`;
      disclaimer += `- AI-generated content has been identified and disclosed\n`;
      disclaimer += `- Users retain responsibility for accuracy and appropriateness\n`;
      disclaimer += `- Data processing complies with GDPR requirements\n`;
      break;
      
    case 'UK':
      disclaimer += `\nUnited Kingdom Compliance:\n`;
      disclaimer += `- This content was generated using AI technology\n`;
      disclaimer += `- Content should be reviewed for accuracy before publication\n`;
      disclaimer += `- Users maintain editorial responsibility\n`;
      break;
      
    case 'US':
      disclaimer += `\nUnited States Compliance:\n`;
      disclaimer += `- AI-generated content disclosure required\n`;
      disclaimer += `- Content accuracy is user responsibility\n`;
      disclaimer += `- First Amendment protections apply\n`;
      break;
      
    case 'CA':
      disclaimer += `\nCanadian Compliance:\n`;
      disclaimer += `- AI-generated content disclosed per Canadian guidelines\n`;
      disclaimer += `- Bilingual requirements may apply for official use\n`;
      disclaimer += `- Content accuracy verification recommended\n`;
      break;
      
    default:
      disclaimer += `\nGeneral Compliance:\n`;
      disclaimer += `- AI-generated content disclosed\n`;
      disclaimer += `- Review local regulations for compliance\n`;
      disclaimer += `- Verify accuracy before use\n`;
  }
  
  // Ethics mode-specific disclaimers
  switch (ethicsMode) {
    case 'academic':
      disclaimer += `\nAcademic Use Notice:\n`;
      disclaimer += `- Proper attribution required for academic submissions\n`;
      disclaimer += `- Cite AI assistance in accordance with institutional policies\n`;
      disclaimer += `- Original research and critical thinking remain essential\n`;
      disclaimer += `- Check institution-specific AI use guidelines\n`;
      break;
      
    case 'political':
      disclaimer += `\nPolitical Content Notice:\n`;
      disclaimer += `- Content has been screened for political bias\n`;
      disclaimer += `- Fact-checking and source verification recommended\n`;
      disclaimer += `- Consider diverse perspectives and viewpoints\n`;
      disclaimer += `- Comply with election and campaign finance laws\n`;
      break;
      
    case 'corporate':
      disclaimer += `\nCorporate Use Notice:\n`;
      disclaimer += `- Review for compliance with company policies\n`;
      disclaimer += `- Legal and compliance team review recommended\n`;
      disclaimer += `- Brand guidelines and messaging consistency required\n`;
      disclaimer += `- Consider regulatory and industry-specific requirements\n`;
      break;
  }
  
  disclaimer += `\nGenerated by SpeechWriter AI | speechwriter.ai\n`;
  disclaimer += `--- END DISCLAIMER ---\n`;
  
  return disclaimer;
}

// Perform comprehensive compliance check
async function performComplianceCheck(
  userId: string,
  speechId: string,
  preferences: any
): Promise<ComplianceCheck> {
  const result: ComplianceCheck = {
    passed: false,
    flags: [],
    disclaimerRequired: true,
    disclaimerText: '',
    academicHonestyRequired: preferences.ethicsMode === 'academic',
    politicalWarningsRequired: preferences.ethicsMode === 'political' || preferences.politicalContentWarnings,
  };

  try {
    // Get all compliance flags for this speech
    const flags = await db
      .select()
      .from(contentComplianceFlags)
      .where(and(
        eq(contentComplianceFlags.speechId, speechId),
        eq(contentComplianceFlags.status, 'active')
      ))
      .orderBy(desc(contentComplianceFlags.createdAt));

    result.flags = flags.map(flag => ({
      id: flag.id,
      type: flag.flagType,
      reason: flag.flagReason,
      description: flag.flagDescription || '',
      severity: flag.severity,
      acknowledged: flag.status === 'acknowledged',
    }));

    // Check if all critical flags are acknowledged
    const criticalFlags = result.flags.filter(f => f.severity === 'critical' && !f.acknowledged);
    const highFlags = result.flags.filter(f => f.severity === 'high' && !f.acknowledged);

    // Generate disclaimer
    result.disclaimerText = generateDisclaimer(
      preferences.jurisdiction as JurisdictionType,
      preferences.ethicsMode as EthicsMode,
      `Speech ${speechId}`
    );

    // Determine if export can proceed
    result.passed = criticalFlags.length === 0 && highFlags.length === 0;

    // Additional checks based on ethics mode
    if (result.academicHonestyRequired && !preferences.academicHonestyAccepted) {
      result.passed = false;
      result.flags.push({
        id: 'academic-honesty-required',
        type: 'academic',
        reason: 'Academic honesty acknowledgment required',
        description: 'You must accept the academic honesty guidelines before exporting in academic mode.',
        severity: 'high',
        acknowledged: false,
      });
    }

    if (result.politicalWarningsRequired) {
      const politicalFlags = result.flags.filter(f => f.type === 'political');
      if (politicalFlags.some(f => !f.acknowledged && ['critical', 'high'].includes(f.severity))) {
        result.passed = false;
      }
    }

    return result;
  } catch (error) {
    console.error('Error performing compliance check:', error);
    throw new Error('Failed to perform compliance check');
  }
}

// Record export compliance
async function recordExportCompliance(
  userId: string,
  speechId: string,
  exportType: string,
  preferences: any,
  complianceCheck: ComplianceCheck,
  acknowledgedFlags: string[]
) {
  try {
    await db.insert(exportComplianceRecords).values({
      speechId,
      userId,
      exportType,
      jurisdiction: preferences.jurisdiction,
      ethicsMode: preferences.ethicsMode,
      complianceChecksCompleted: complianceCheck.passed,
      disclaimerIncluded: true,
      disclaimerVersion: '1.0',
      flagsAcknowledged: acknowledgedFlags.length > 0,
      acknowledgedFlagIds: acknowledgedFlags,
      exportMetadata: {
        flagCount: complianceCheck.flags.length,
        criticalFlags: complianceCheck.flags.filter(f => f.severity === 'critical').length,
        timestamp: new Date().toISOString(),
        complianceVersion: '1.0',
      },
    });
  } catch (error) {
    console.error('Error recording export compliance:', error);
    throw new Error('Failed to record export compliance');
  }
}

export const handler: Handler = async (event, context) => {
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Content-Type': 'application/json',
  };

  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return { statusCode: 200, headers, body: '' };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ success: false, error: 'Method not allowed' }),
    };
  }

  try {
    // Extract user ID from Authorization header (simplified for demo)
    const authHeader = event.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return {
        statusCode: 401,
        headers,
        body: JSON.stringify({ success: false, error: 'Unauthorized' }),
      };
    }

    const userId = 'user-id-placeholder'; // Replace with actual JWT validation

    if (!event.body) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ success: false, error: 'Request body is required' }),
      };
    }

    const request: ExportRequest = JSON.parse(event.body);

    // Validate required fields
    if (!request.speechId || !request.exportType) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ 
          success: false, 
          error: 'speechId and exportType are required' 
        }),
      };
    }

    // Get user preferences
    const preferences = await db
      .select()
      .from(userPreferences)
      .where(eq(userPreferences.userId, userId))
      .limit(1);

    if (preferences.length === 0) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ 
          success: false, 
          error: 'User preferences not found. Please configure your compliance settings first.' 
        }),
      };
    }

    const userPrefs = preferences[0];

    // Perform compliance check
    const complianceCheck = await performComplianceCheck(userId, request.speechId, userPrefs);

    // If compliance check fails and not forcing export
    if (!complianceCheck.passed && !request.forceExport) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          success: false,
          error: 'Compliance check failed',
          data: {
            complianceCheck,
            requiresAcknowledgment: true,
          },
        }),
      };
    }

    // Acknowledge flags if provided
    if (request.acknowledgedFlags && request.acknowledgedFlags.length > 0) {
      await db
        .update(contentComplianceFlags)
        .set({
          status: 'acknowledged',
          acknowledgedByUserId: userId,
          acknowledgedAt: new Date(),
          updatedAt: new Date(),
        })
        .where(and(
          eq(contentComplianceFlags.speechId, request.speechId),
          // Only acknowledge flags that were provided
          // Note: This is a simplified version - in production, use a more specific where clause
        ));
    }

    // Record export compliance
    await recordExportCompliance(
      userId,
      request.speechId,
      request.exportType,
      userPrefs,
      complianceCheck,
      request.acknowledgedFlags || []
    );

    // TODO: Integrate with actual export functions (export-pdf-with-gates.ts, export-docx.ts)
    // For now, return success with disclaimer
    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        success: true,
        data: {
          exportReady: true,
          disclaimer: complianceCheck.disclaimerText,
          complianceRecord: {
            jurisdiction: userPrefs.jurisdiction,
            ethicsMode: userPrefs.ethicsMode,
            flagsAcknowledged: (request.acknowledgedFlags || []).length,
            exportType: request.exportType,
          },
          nextSteps: [
            'Export will include compliance disclaimer',
            'All acknowledged flags have been recorded',
            'Download will begin shortly',
          ],
        },
      }),
    };
  } catch (error) {
    console.error('Export compliance error:', error);
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        success: false,
        error: 'Internal server error during compliance check',
      }),
    };
  }
};