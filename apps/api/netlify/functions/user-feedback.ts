import { Handler, HandlerEvent } from '@netlify/functions'\nimport { z } from 'zod'\nimport { drizzle } from 'drizzle-orm/postgres-js'\nimport { eq, and, desc } from 'drizzle-orm'\nimport postgres from 'postgres'\nimport { userFeedback, speeches, speechSections } from '@speechwriter/database/schema'\nimport jwt from 'jsonwebtoken'\nimport { v4 as uuidv4 } from 'uuid'\n\nconst client = postgres(process.env.DATABASE_URL!, { prepare: false })\nconst db = drizzle(client, { schema: { userFeedback, speeches, speechSections } })\n\nconst feedbackSchema = z.object({\n  type: z.enum(['outline', 'draft', 'humanization', 'general']),\n  rating: z.number().min(1).max(5),\n  comment: z.string().optional(),\n  speechId: z.string().uuid().optional(),\n  sectionId: z.string().uuid().optional(),\n  stage: z.string().optional(), // e.g., 'passA', 'passB', 'critic1'\n  metadata: z.record(z.any()).optional()\n})\n\nconst verifyToken = (token: string) => {\n  try {\n    return jwt.verify(token, process.env.NEXTAUTH_SECRET!)\n  } catch {\n    return null\n  }\n}\n\nconst handler: Handler = async (event: HandlerEvent) => {\n  if (event.httpMethod === 'OPTIONS') {\n    return {\n      statusCode: 200,\n      headers: {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n        'Access-Control-Allow-Methods': 'POST, GET'\n      },\n      body: ''\n    }\n  }\n\n  if (event.httpMethod === 'POST') {\n    try {\n      // Verify authentication\n      const authHeader = event.headers.authorization\n      if (!authHeader?.startsWith('Bearer ')) {\n        return {\n          statusCode: 401,\n          body: JSON.stringify({ error: 'Unauthorized' })\n        }\n      }\n\n      const token = authHeader.replace('Bearer ', '')\n      const decoded = verifyToken(token) as any\n      if (!decoded?.sub) {\n        return {\n          statusCode: 401,\n          body: JSON.stringify({ error: 'Invalid token' })\n        }\n      }\n\n      const userId = decoded.sub\n\n      // Parse and validate request\n      const body = JSON.parse(event.body || '{}')\n      const feedbackData = feedbackSchema.parse(body)\n\n      // Verify speech ownership if speechId provided\n      if (feedbackData.speechId) {\n        const [speech] = await db\n          .select()\n          .from(speeches)\n          .where(eq(speeches.id, feedbackData.speechId))\n          .limit(1)\n\n        if (!speech || speech.userId !== userId) {\n          return {\n            statusCode: 404,\n            body: JSON.stringify({ error: 'Speech not found' })\n          }\n        }\n      }\n\n      // Verify section ownership if sectionId provided\n      if (feedbackData.sectionId) {\n        const [section] = await db\n          .select({ speechId: speechSections.speechId })\n          .from(speechSections)\n          .where(eq(speechSections.id, feedbackData.sectionId))\n          .limit(1)\n\n        if (!section) {\n          return {\n            statusCode: 404,\n            body: JSON.stringify({ error: 'Section not found' })\n          }\n        }\n\n        // Verify speech ownership through section\n        const [speech] = await db\n          .select()\n          .from(speeches)\n          .where(eq(speeches.id, section.speechId))\n          .limit(1)\n\n        if (!speech || speech.userId !== userId) {\n          return {\n            statusCode: 404,\n            body: JSON.stringify({ error: 'Speech not found' })\n          }\n        }\n      }\n\n      // Create feedback record\n      const [feedback] = await db\n        .insert(userFeedback)\n        .values({\n          id: uuidv4(),\n          userId,\n          type: feedbackData.type,\n          rating: feedbackData.rating,\n          comment: feedbackData.comment || null,\n          speechId: feedbackData.speechId || null,\n          sectionId: feedbackData.sectionId || null,\n          stage: feedbackData.stage || null,\n          metadata: feedbackData.metadata || null,\n          createdAt: new Date(),\n          updatedAt: new Date()\n        })\n        .returning()\n\n      return {\n        statusCode: 201,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          feedback: {\n            id: feedback.id,\n            type: feedback.type,\n            rating: feedback.rating,\n            comment: feedback.comment,\n            createdAt: feedback.createdAt\n          },\n          message: 'Feedback submitted successfully'\n        })\n      }\n\n    } catch (error) {\n      console.error('Error submitting feedback:', error)\n      return {\n        statusCode: 500,\n        body: JSON.stringify({ \n          error: 'Failed to submit feedback',\n          details: process.env.NODE_ENV === 'development' ? error.message : undefined\n        })\n      }\n    }\n  }\n\n  if (event.httpMethod === 'GET') {\n    try {\n      // Get feedback analytics (admin only or user's own feedback)\n      const authHeader = event.headers.authorization\n      if (!authHeader?.startsWith('Bearer ')) {\n        return {\n          statusCode: 401,\n          body: JSON.stringify({ error: 'Unauthorized' })\n        }\n      }\n\n      const token = authHeader.replace('Bearer ', '')\n      const decoded = verifyToken(token) as any\n      if (!decoded?.sub) {\n        return {\n          statusCode: 401,\n          body: JSON.stringify({ error: 'Invalid token' })\n        }\n      }\n\n      const userId = decoded.sub\n      const isAdmin = decoded.role === 'admin' // Adjust based on your auth system\n      const speechId = event.queryStringParameters?.speechId\n      const type = event.queryStringParameters?.type\n\n      let feedbackQuery = db.select().from(userFeedback)\n\n      // Filter by user unless admin\n      if (!isAdmin) {\n        feedbackQuery = feedbackQuery.where(eq(userFeedback.userId, userId))\n      }\n\n      // Filter by speech if provided\n      if (speechId) {\n        feedbackQuery = feedbackQuery.where(\n          isAdmin \n            ? eq(userFeedback.speechId, speechId)\n            : and(\n                eq(userFeedback.userId, userId),\n                eq(userFeedback.speechId, speechId)\n              )\n        )\n      }\n\n      // Filter by type if provided\n      if (type) {\n        feedbackQuery = feedbackQuery.where(eq(userFeedback.type, type as any))\n      }\n\n      const feedbackResults = await feedbackQuery\n        .orderBy(desc(userFeedback.createdAt))\n        .limit(100)\n\n      // Calculate analytics\n      const analytics = {\n        totalFeedback: feedbackResults.length,\n        averageRating: feedbackResults.length > 0 \n          ? feedbackResults.reduce((sum, f) => sum + f.rating, 0) / feedbackResults.length \n          : 0,\n        ratingDistribution: {\n          1: feedbackResults.filter(f => f.rating === 1).length,\n          2: feedbackResults.filter(f => f.rating === 2).length,\n          3: feedbackResults.filter(f => f.rating === 3).length,\n          4: feedbackResults.filter(f => f.rating === 4).length,\n          5: feedbackResults.filter(f => f.rating === 5).length,\n        },\n        typeBreakdown: {\n          outline: feedbackResults.filter(f => f.type === 'outline').length,\n          draft: feedbackResults.filter(f => f.type === 'draft').length,\n          humanization: feedbackResults.filter(f => f.type === 'humanization').length,\n          general: feedbackResults.filter(f => f.type === 'general').length,\n        }\n      }\n\n      return {\n        statusCode: 200,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          feedback: feedbackResults.map(f => ({\n            id: f.id,\n            type: f.type,\n            rating: f.rating,\n            comment: f.comment,\n            speechId: f.speechId,\n            sectionId: f.sectionId,\n            stage: f.stage,\n            createdAt: f.createdAt,\n            // Only include userId for admin\n            ...(isAdmin && { userId: f.userId })\n          })),\n          analytics\n        })\n      }\n\n    } catch (error) {\n      console.error('Error fetching feedback:', error)\n      return {\n        statusCode: 500,\n        body: JSON.stringify({ \n          error: 'Failed to fetch feedback',\n          details: process.env.NODE_ENV === 'development' ? error.message : undefined\n        })\n      }\n    }\n  }\n\n  return {\n    statusCode: 405,\n    body: JSON.stringify({ error: 'Method not allowed' })\n  }\n}\n\nexport { handler }"