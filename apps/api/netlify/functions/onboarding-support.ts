import { Handler, HandlerEvent } from '@netlify/functions'\nimport { z } from 'zod'\nimport { drizzle } from 'drizzle-orm/postgres-js'\nimport { eq, and } from 'drizzle-orm'\nimport postgres from 'postgres'\nimport { users, onboardingProgress, supportTickets, tutorialProgress } from '@speechwriter/database/schema'\nimport jwt from 'jsonwebtoken'\nimport { v4 as uuidv4 } from 'uuid'\nimport { trackError } from './lib/error-tracking'\nimport { trackSpeechEvent } from './lib/analytics-utils'\nimport { ANALYTICS_EVENTS } from '@speechwriter/analytics'\n\nconst client = postgres(process.env.DATABASE_URL!, { prepare: false })\nconst db = drizzle(client, { schema: { users, onboardingProgress, supportTickets, tutorialProgress } })\n\nconst onboardingSchema = z.object({\n  action: z.enum(['start', 'complete-step', 'skip-step', 'complete', 'get-progress']),\n  step: z.string().optional(),\n  data: z.record(z.any()).optional()\n})\n\nconst supportSchema = z.object({\n  type: z.enum(['bug', 'feature', 'question', 'billing', 'technical']),\n  subject: z.string().min(1).max(200),\n  message: z.string().min(10).max(5000),\n  priority: z.enum(['low', 'medium', 'high', 'urgent']).optional().default('medium'),\n  attachments: z.array(z.string()).optional(),\n  metadata: z.record(z.any()).optional()\n})\n\nconst tutorialSchema = z.object({\n  tutorialId: z.string(),\n  stepId: z.string().optional(),\n  completed: z.boolean().optional(),\n  timeSpent: z.number().optional()\n})\n\nconst verifyToken = (token: string) => {\n  try {\n    return jwt.verify(token, process.env.NEXTAUTH_SECRET!)\n  } catch {\n    return null\n  }\n}\n\nconst ONBOARDING_STEPS = [\n  {\n    id: 'welcome',\n    title: 'Welcome to SpeechWriter',\n    description: 'Learn about our AI-powered speech creation platform',\n    estimatedTime: 2,\n    required: true\n  },\n  {\n    id: 'create-persona',\n    title: 'Create Your Speaking Persona',\n    description: 'Define your unique speaking style and preferences',\n    estimatedTime: 5,\n    required: true\n  },\n  {\n    id: 'first-speech',\n    title: 'Create Your First Speech',\n    description: 'Walk through the complete speech creation process',\n    estimatedTime: 10,\n    required: true\n  },\n  {\n    id: 'add-stories',\n    title: 'Build Your Story Vault',\n    description: 'Add personal stories to enhance your speeches',\n    estimatedTime: 5,\n    required: false\n  },\n  {\n    id: 'explore-features',\n    title: 'Explore Advanced Features',\n    description: 'Discover humanization, fact-checking, and export options',\n    estimatedTime: 8,\n    required: false\n  },\n  {\n    id: 'practice-delivery',\n    title: 'Practice with Teleprompter',\n    description: 'Use our teleprompter and rehearsal tools',\n    estimatedTime: 5,\n    required: false\n  }\n]\n\nconst handler: Handler = async (event: HandlerEvent) => {\n  if (event.httpMethod === 'OPTIONS') {\n    return {\n      statusCode: 200,\n      headers: {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n        'Access-Control-Allow-Methods': 'POST, GET, PUT'\n      },\n      body: ''\n    }\n  }\n\n  try {\n    // Verify authentication\n    const authHeader = event.headers.authorization\n    if (!authHeader?.startsWith('Bearer ')) {\n      return {\n        statusCode: 401,\n        body: JSON.stringify({ error: 'Unauthorized' })\n      }\n    }\n\n    const token = authHeader.replace('Bearer ', '')\n    const decoded = verifyToken(token) as any\n    if (!decoded?.sub) {\n      return {\n        statusCode: 401,\n        body: JSON.stringify({ error: 'Invalid token' })\n      }\n    }\n\n    const userId = decoded.sub\n    const endpoint = event.path.split('/').pop()\n\n    switch (endpoint) {\n      case 'onboarding':\n        return await handleOnboarding(event, userId)\n      \n      case 'support':\n        return await handleSupport(event, userId)\n      \n      case 'tutorial':\n        return await handleTutorial(event, userId)\n      \n      case 'help':\n        return await handleHelp(event, userId)\n      \n      default:\n        return {\n          statusCode: 404,\n          body: JSON.stringify({ error: 'Endpoint not found' })\n        }\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'onboarding-support',\n      additionalData: { endpoint: event.path }\n    })\n    \n    return {\n      statusCode: 500,\n      body: JSON.stringify({ \n        error: 'Request failed',\n        details: process.env.NODE_ENV === 'development' ? error.message : undefined\n      })\n    }\n  }\n}\n\n/**\n * Handle onboarding requests\n */\nasync function handleOnboarding(event: HandlerEvent, userId: string) {\n  if (event.httpMethod === 'GET') {\n    return await getOnboardingProgress(userId)\n  }\n\n  if (event.httpMethod === 'POST') {\n    const body = JSON.parse(event.body || '{}')\n    const { action, step, data } = onboardingSchema.parse(body)\n\n    switch (action) {\n      case 'start':\n        return await startOnboarding(userId)\n      \n      case 'complete-step':\n        return await completeOnboardingStep(userId, step!, data)\n      \n      case 'skip-step':\n        return await skipOnboardingStep(userId, step!)\n      \n      case 'complete':\n        return await completeOnboarding(userId)\n      \n      case 'get-progress':\n        return await getOnboardingProgress(userId)\n      \n      default:\n        return {\n          statusCode: 400,\n          body: JSON.stringify({ error: 'Invalid action' })\n        }\n    }\n  }\n\n  return {\n    statusCode: 405,\n    body: JSON.stringify({ error: 'Method not allowed' })\n  }\n}\n\n/**\n * Handle support requests\n */\nasync function handleSupport(event: HandlerEvent, userId: string) {\n  if (event.httpMethod === 'POST') {\n    const body = JSON.parse(event.body || '{}')\n    const supportData = supportSchema.parse(body)\n    return await createSupportTicket(userId, supportData)\n  }\n\n  if (event.httpMethod === 'GET') {\n    return await getUserSupportTickets(userId)\n  }\n\n  return {\n    statusCode: 405,\n    body: JSON.stringify({ error: 'Method not allowed' })\n  }\n}\n\n/**\n * Handle tutorial progress\n */\nasync function handleTutorial(event: HandlerEvent, userId: string) {\n  if (event.httpMethod === 'POST') {\n    const body = JSON.parse(event.body || '{}')\n    const tutorialData = tutorialSchema.parse(body)\n    return await updateTutorialProgress(userId, tutorialData)\n  }\n\n  if (event.httpMethod === 'GET') {\n    const tutorialId = event.queryStringParameters?.tutorialId\n    return await getTutorialProgress(userId, tutorialId)\n  }\n\n  return {\n    statusCode: 405,\n    body: JSON.stringify({ error: 'Method not allowed' })\n  }\n}\n\n/**\n * Handle help requests\n */\nasync function handleHelp(event: HandlerEvent, userId: string) {\n  const query = event.queryStringParameters?.q\n  const category = event.queryStringParameters?.category\n  \n  return await searchHelpContent(query, category)\n}\n\n/**\n * Start onboarding process\n */\nasync function startOnboarding(userId: string) {\n  try {\n    // Check if onboarding already exists\n    const [existing] = await db\n      .select()\n      .from(onboardingProgress)\n      .where(eq(onboardingProgress.userId, userId))\n      .limit(1)\n\n    if (existing) {\n      return {\n        statusCode: 200,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          message: 'Onboarding already started',\n          progress: existing\n        })\n      }\n    }\n\n    // Create new onboarding record\n    const [progress] = await db\n      .insert(onboardingProgress)\n      .values({\n        id: uuidv4(),\n        userId,\n        currentStep: 'welcome',\n        completedSteps: [],\n        skippedSteps: [],\n        startedAt: new Date(),\n        isCompleted: false\n      })\n      .returning()\n\n    // Track analytics\n    await trackSpeechEvent(userId, null, ANALYTICS_EVENTS.ONBOARDING_STARTED, {\n      first_step: 'welcome'\n    })\n\n    return {\n      statusCode: 201,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        message: 'Onboarding started',\n        progress,\n        steps: ONBOARDING_STEPS,\n        nextStep: ONBOARDING_STEPS[0]\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'onboarding-support',\n      userId,\n      additionalData: { action: 'start_onboarding' }\n    })\n    throw error\n  }\n}\n\n/**\n * Complete an onboarding step\n */\nasync function completeOnboardingStep(userId: string, stepId: string, data?: any) {\n  try {\n    const [progress] = await db\n      .select()\n      .from(onboardingProgress)\n      .where(eq(onboardingProgress.userId, userId))\n      .limit(1)\n\n    if (!progress) {\n      return {\n        statusCode: 404,\n        body: JSON.stringify({ error: 'Onboarding not started' })\n      }\n    }\n\n    const completedSteps = [...(progress.completedSteps as string[] || [])]\n    if (!completedSteps.includes(stepId)) {\n      completedSteps.push(stepId)\n    }\n\n    // Find next step\n    const currentStepIndex = ONBOARDING_STEPS.findIndex(s => s.id === stepId)\n    const nextStep = ONBOARDING_STEPS[currentStepIndex + 1]?.id || null\n\n    // Update progress\n    const [updatedProgress] = await db\n      .update(onboardingProgress)\n      .set({\n        currentStep: nextStep,\n        completedSteps,\n        stepData: {\n          ...(progress.stepData as any || {}),\n          [stepId]: data\n        },\n        updatedAt: new Date()\n      })\n      .where(eq(onboardingProgress.userId, userId))\n      .returning()\n\n    // Track analytics\n    await trackSpeechEvent(userId, null, ANALYTICS_EVENTS.ONBOARDING_STEP_COMPLETED, {\n      step_id: stepId,\n      step_index: currentStepIndex,\n      next_step: nextStep,\n      has_data: !!data\n    })\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        message: 'Step completed',\n        progress: updatedProgress,\n        nextStep: nextStep ? ONBOARDING_STEPS.find(s => s.id === nextStep) : null,\n        completionPercentage: Math.round((completedSteps.length / ONBOARDING_STEPS.length) * 100)\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'onboarding-support',\n      userId,\n      additionalData: { action: 'complete_step', step: stepId }\n    })\n    throw error\n  }\n}\n\n/**\n * Skip an onboarding step\n */\nasync function skipOnboardingStep(userId: string, stepId: string) {\n  try {\n    const [progress] = await db\n      .select()\n      .from(onboardingProgress)\n      .where(eq(onboardingProgress.userId, userId))\n      .limit(1)\n\n    if (!progress) {\n      return {\n        statusCode: 404,\n        body: JSON.stringify({ error: 'Onboarding not started' })\n      }\n    }\n\n    const skippedSteps = [...(progress.skippedSteps as string[] || [])]\n    if (!skippedSteps.includes(stepId)) {\n      skippedSteps.push(stepId)\n    }\n\n    // Find next step\n    const currentStepIndex = ONBOARDING_STEPS.findIndex(s => s.id === stepId)\n    const nextStep = ONBOARDING_STEPS[currentStepIndex + 1]?.id || null\n\n    // Update progress\n    await db\n      .update(onboardingProgress)\n      .set({\n        currentStep: nextStep,\n        skippedSteps,\n        updatedAt: new Date()\n      })\n      .where(eq(onboardingProgress.userId, userId))\n\n    // Track analytics\n    await trackSpeechEvent(userId, null, ANALYTICS_EVENTS.ONBOARDING_STEP_SKIPPED, {\n      step_id: stepId,\n      step_index: currentStepIndex,\n      next_step: nextStep\n    })\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        message: 'Step skipped',\n        nextStep: nextStep ? ONBOARDING_STEPS.find(s => s.id === nextStep) : null\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'onboarding-support',\n      userId,\n      additionalData: { action: 'skip_step', step: stepId }\n    })\n    throw error\n  }\n}\n\n/**\n * Complete onboarding\n */\nasync function completeOnboarding(userId: string) {\n  try {\n    await db\n      .update(onboardingProgress)\n      .set({\n        isCompleted: true,\n        completedAt: new Date(),\n        updatedAt: new Date()\n      })\n      .where(eq(onboardingProgress.userId, userId))\n\n    // Track analytics\n    await trackSpeechEvent(userId, null, ANALYTICS_EVENTS.ONBOARDING_COMPLETED, {\n      completion_time: new Date().toISOString()\n    })\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        message: 'Onboarding completed',\n        congratulations: 'Welcome to SpeechWriter! You\\'re ready to create amazing speeches.'\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'onboarding-support',\n      userId,\n      additionalData: { action: 'complete_onboarding' }\n    })\n    throw error\n  }\n}\n\n/**\n * Get onboarding progress\n */\nasync function getOnboardingProgress(userId: string) {\n  try {\n    const [progress] = await db\n      .select()\n      .from(onboardingProgress)\n      .where(eq(onboardingProgress.userId, userId))\n      .limit(1)\n\n    if (!progress) {\n      return {\n        statusCode: 200,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          hasStarted: false,\n          steps: ONBOARDING_STEPS,\n          nextStep: ONBOARDING_STEPS[0]\n        })\n      }\n    }\n\n    const completedSteps = progress.completedSteps as string[] || []\n    const skippedSteps = progress.skippedSteps as string[] || []\n    const completionPercentage = Math.round((completedSteps.length / ONBOARDING_STEPS.length) * 100)\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        hasStarted: true,\n        progress,\n        steps: ONBOARDING_STEPS.map(step => ({\n          ...step,\n          completed: completedSteps.includes(step.id),\n          skipped: skippedSteps.includes(step.id),\n          current: step.id === progress.currentStep\n        })),\n        completionPercentage,\n        isCompleted: progress.isCompleted\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'onboarding-support',\n      userId,\n      additionalData: { action: 'get_progress' }\n    })\n    throw error\n  }\n}\n\n/**\n * Create support ticket\n */\nasync function createSupportTicket(userId: string, supportData: any) {\n  try {\n    const [ticket] = await db\n      .insert(supportTickets)\n      .values({\n        id: uuidv4(),\n        userId,\n        type: supportData.type,\n        subject: supportData.subject,\n        message: supportData.message,\n        priority: supportData.priority,\n        status: 'open',\n        attachments: supportData.attachments || null,\n        metadata: supportData.metadata || null,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      })\n      .returning()\n\n    // Send notification to support team (implement notification service)\n    await notifySupportTeam(ticket)\n\n    // Track analytics\n    await trackSpeechEvent(userId, null, ANALYTICS_EVENTS.SUPPORT_TICKET_CREATED, {\n      ticket_type: supportData.type,\n      priority: supportData.priority\n    })\n\n    return {\n      statusCode: 201,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        message: 'Support ticket created',\n        ticket: {\n          id: ticket.id,\n          subject: ticket.subject,\n          status: ticket.status,\n          priority: ticket.priority,\n          createdAt: ticket.createdAt\n        },\n        expectedResponse: getSupportResponseTime(supportData.priority)\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'onboarding-support',\n      userId,\n      additionalData: { action: 'create_ticket', type: supportData.type }\n    })\n    throw error\n  }\n}\n\n/**\n * Get user support tickets\n */\nasync function getUserSupportTickets(userId: string) {\n  try {\n    const tickets = await db\n      .select()\n      .from(supportTickets)\n      .where(eq(supportTickets.userId, userId))\n      .orderBy(desc(supportTickets.createdAt))\n      .limit(50)\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        tickets: tickets.map(ticket => ({\n          id: ticket.id,\n          type: ticket.type,\n          subject: ticket.subject,\n          status: ticket.status,\n          priority: ticket.priority,\n          createdAt: ticket.createdAt,\n          updatedAt: ticket.updatedAt,\n          resolvedAt: ticket.resolvedAt\n        }))\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'onboarding-support',\n      userId,\n      additionalData: { action: 'get_tickets' }\n    })\n    throw error\n  }\n}\n\n/**\n * Update tutorial progress\n */\nasync function updateTutorialProgress(userId: string, tutorialData: any) {\n  try {\n    const [progress] = await db\n      .insert(tutorialProgress)\n      .values({\n        id: uuidv4(),\n        userId,\n        tutorialId: tutorialData.tutorialId,\n        stepId: tutorialData.stepId || null,\n        completed: tutorialData.completed || false,\n        timeSpent: tutorialData.timeSpent || null,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      })\n      .onConflictDoUpdate({\n        target: [tutorialProgress.userId, tutorialProgress.tutorialId, tutorialProgress.stepId],\n        set: {\n          completed: tutorialData.completed,\n          timeSpent: tutorialData.timeSpent,\n          updatedAt: new Date()\n        }\n      })\n      .returning()\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        message: 'Tutorial progress updated',\n        progress\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'onboarding-support',\n      userId,\n      additionalData: { action: 'update_tutorial', tutorial: tutorialData.tutorialId }\n    })\n    throw error\n  }\n}\n\n/**\n * Get tutorial progress\n */\nasync function getTutorialProgress(userId: string, tutorialId?: string) {\n  try {\n    let query = db.select().from(tutorialProgress).where(eq(tutorialProgress.userId, userId))\n    \n    if (tutorialId) {\n      query = query.where(eq(tutorialProgress.tutorialId, tutorialId))\n    }\n    \n    const progress = await query.orderBy(desc(tutorialProgress.updatedAt))\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        progress\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'onboarding-support',\n      userId,\n      additionalData: { action: 'get_tutorial_progress', tutorial: tutorialId }\n    })\n    throw error\n  }\n}\n\n/**\n * Search help content\n */\nasync function searchHelpContent(query?: string, category?: string) {\n  // This would typically search a knowledge base or CMS\n  // For now, return static help content\n  \n  const helpContent = {\n    categories: [\n      'getting-started',\n      'speech-creation',\n      'personas-and-style',\n      'story-vault',\n      'humanization',\n      'export-and-sharing',\n      'billing-and-account',\n      'troubleshooting'\n    ],\n    articles: [\n      {\n        id: 'create-first-speech',\n        title: 'Creating Your First Speech',\n        category: 'getting-started',\n        content: 'Step-by-step guide to creating your first speech...',\n        tags: ['beginner', 'speech', 'tutorial']\n      },\n      {\n        id: 'persona-setup',\n        title: 'Setting Up Your Speaking Persona',\n        category: 'personas-and-style',\n        content: 'Learn how to define your unique speaking style...',\n        tags: ['persona', 'style', 'customization']\n      },\n      {\n        id: 'story-vault-guide',\n        title: 'Building Your Story Vault',\n        category: 'story-vault',\n        content: 'How to add and organize personal stories...',\n        tags: ['stories', 'vault', 'organization']\n      }\n    ]\n  }\n\n  let filteredArticles = helpContent.articles\n  \n  if (category) {\n    filteredArticles = filteredArticles.filter(article => article.category === category)\n  }\n  \n  if (query) {\n    const searchTerm = query.toLowerCase()\n    filteredArticles = filteredArticles.filter(article => \n      article.title.toLowerCase().includes(searchTerm) ||\n      article.content.toLowerCase().includes(searchTerm) ||\n      article.tags.some(tag => tag.toLowerCase().includes(searchTerm))\n    )\n  }\n\n  return {\n    statusCode: 200,\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*'\n    },\n    body: JSON.stringify({\n      categories: helpContent.categories,\n      articles: filteredArticles,\n      totalResults: filteredArticles.length\n    })\n  }\n}\n\n/**\n * Notify support team of new ticket\n */\nasync function notifySupportTeam(ticket: any) {\n  try {\n    // In production, integrate with support system (Zendesk, Intercom, etc.)\n    console.log(`New support ticket: ${ticket.id} - ${ticket.subject}`)\n    \n    // Could send email, Slack notification, etc.\n  } catch (error) {\n    console.error('Failed to notify support team:', error)\n  }\n}\n\n/**\n * Get expected response time based on priority\n */\nfunction getSupportResponseTime(priority: string): string {\n  const responseTimes = {\n    urgent: '2-4 hours',\n    high: '4-8 hours',\n    medium: '1-2 business days',\n    low: '2-3 business days'\n  }\n  \n  return responseTimes[priority] || responseTimes.medium\n}\n\nexport { handler }"