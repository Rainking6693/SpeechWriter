import { Handler, HandlerEvent } from '@netlify/functions'\nimport { z } from 'zod'\nimport { drizzle } from 'drizzle-orm/postgres-js'\nimport { eq } from 'drizzle-orm'\nimport postgres from 'postgres'\nimport { speeches, speechSections } from '@speechwriter/database/schema'\nimport jwt from 'jsonwebtoken'\nimport { robustAICall } from './lib/ai-fallback-utils'\nimport { trackSpeechEvent } from './lib/analytics-utils'\nimport { ANALYTICS_EVENTS } from '@speechwriter/analytics'\n\nconst client = postgres(process.env.DATABASE_URL!, { prepare: false })\nconst db = drizzle(client, { schema: { speeches, speechSections } })\n\nconst accessibilitySchema = z.object({\n  speechId: z.string().uuid(),\n  sectionId: z.string().uuid().optional(),\n  text: z.string().min(1),\n  targetAudienceLevel: z.enum(['elementary', 'middle', 'high-school', 'college', 'graduate', 'professional']).optional(),\n  includeAISuggestions: z.boolean().optional().default(true)\n})\n\nconst verifyToken = (token: string) => {\n  try {\n    return jwt.verify(token, process.env.NEXTAUTH_SECRET!)\n  } catch {\n    return null\n  }\n}\n\nconst handler: Handler = async (event: HandlerEvent) => {\n  if (event.httpMethod !== 'POST') {\n    return {\n      statusCode: 405,\n      body: JSON.stringify({ error: 'Method not allowed' })\n    }\n  }\n\n  try {\n    // Verify authentication\n    const authHeader = event.headers.authorization\n    if (!authHeader?.startsWith('Bearer ')) {\n      return {\n        statusCode: 401,\n        body: JSON.stringify({ error: 'Unauthorized' })\n      }\n    }\n\n    const token = authHeader.replace('Bearer ', '')\n    const decoded = verifyToken(token) as any\n    if (!decoded?.sub) {\n      return {\n        statusCode: 401,\n        body: JSON.stringify({ error: 'Invalid token' })\n      }\n    }\n\n    const userId = decoded.sub\n\n    // Parse and validate request\n    const body = JSON.parse(event.body || '{}')\n    const { speechId, sectionId, text, targetAudienceLevel, includeAISuggestions } = accessibilitySchema.parse(body)\n\n    // Verify speech ownership\n    const [speech] = await db\n      .select()\n      .from(speeches)\n      .where(eq(speeches.id, speechId))\n      .limit(1)\n\n    if (!speech || speech.userId !== userId) {\n      return {\n        statusCode: 404,\n        body: JSON.stringify({ error: 'Speech not found' })\n      }\n    }\n\n    // Track analytics\n    await trackSpeechEvent(userId, speechId, ANALYTICS_EVENTS.ACCESSIBILITY_CHECK, {\n      section_id: sectionId,\n      text_length: text.length,\n      target_level: targetAudienceLevel\n    })\n\n    // Perform comprehensive accessibility analysis\n    const readabilityScores = calculateReadabilityScores(text)\n    const complexityAnalysis = analyzeComplexity(text)\n    const structureAnalysis = analyzeStructure(text)\n    \n    let aiSuggestions = null\n    if (includeAISuggestions) {\n      aiSuggestions = await generateAISuggestions(text, targetAudienceLevel, readabilityScores)\n    }\n\n    const overallAssessment = generateOverallAssessment(readabilityScores, complexityAnalysis, structureAnalysis, targetAudienceLevel)\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        readability: readabilityScores,\n        complexity: complexityAnalysis,\n        structure: structureAnalysis,\n        aiSuggestions,\n        assessment: overallAssessment,\n        recommendations: generateRecommendations(overallAssessment, targetAudienceLevel),\n        message: 'Accessibility analysis completed'\n      })\n    }\n\n  } catch (error) {\n    console.error('Error in accessibility check:', error)\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ \n        error: 'Failed to perform accessibility check',\n        details: process.env.NODE_ENV === 'development' ? error.message : undefined\n      })\n    }\n  }\n}\n\n/**\n * Calculate various readability scores\n */\nfunction calculateReadabilityScores(text: string) {\n  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0)\n  const words = text.split(/\\s+/).filter(w => w.length > 0)\n  const syllables = words.reduce((total, word) => total + countSyllables(word), 0)\n  const characters = text.replace(/\\s/g, '').length\n\n  const avgWordsPerSentence = words.length / sentences.length\n  const avgSyllablesPerWord = syllables / words.length\n  const avgCharactersPerWord = characters / words.length\n\n  // Flesch Reading Ease Score\n  const fleschScore = 206.835 - (1.015 * avgWordsPerSentence) - (84.6 * avgSyllablesPerWord)\n  \n  // Flesch-Kincaid Grade Level\n  const fleschKincaidGrade = (0.39 * avgWordsPerSentence) + (11.8 * avgSyllablesPerWord) - 15.59\n  \n  // Automated Readability Index (ARI)\n  const ariScore = (4.71 * avgCharactersPerWord) + (0.5 * avgWordsPerSentence) - 21.43\n  \n  // Simple Measure of Gobbledygook (SMOG)\n  const complexWords = words.filter(word => countSyllables(word) >= 3).length\n  const smogScore = 1.0430 * Math.sqrt(complexWords * (30 / sentences.length)) + 3.1291\n\n  return {\n    fleschReadingEase: Math.round(fleschScore * 10) / 10,\n    fleschKincaidGrade: Math.round(fleschKincaidGrade * 10) / 10,\n    automatedReadabilityIndex: Math.round(ariScore * 10) / 10,\n    smogIndex: Math.round(smogScore * 10) / 10,\n    statistics: {\n      sentences: sentences.length,\n      words: words.length,\n      syllables,\n      characters,\n      avgWordsPerSentence: Math.round(avgWordsPerSentence * 10) / 10,\n      avgSyllablesPerWord: Math.round(avgSyllablesPerWord * 10) / 10,\n      avgCharactersPerWord: Math.round(avgCharactersPerWord * 10) / 10\n    }\n  }\n}\n\n/**\n * Analyze text complexity beyond basic readability\n */\nfunction analyzeComplexity(text: string) {\n  const words = text.split(/\\s+/).filter(w => w.length > 0)\n  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0)\n  \n  // Complex word analysis\n  const longWords = words.filter(word => word.length > 6)\n  const veryLongWords = words.filter(word => word.length > 10)\n  const complexWords = words.filter(word => countSyllables(word) >= 3)\n  \n  // Sentence complexity\n  const longSentences = sentences.filter(sentence => sentence.split(/\\s+/).length > 20)\n  const veryLongSentences = sentences.filter(sentence => sentence.split(/\\s+/).length > 30)\n  \n  // Jargon and technical terms (basic detection)\n  const technicalTerms = detectTechnicalTerms(text)\n  const acronyms = text.match(/\\b[A-Z]{2,}\\b/g) || []\n  \n  // Passive voice detection (simplified)\n  const passiveVoiceMatches = text.match(/\\b(was|were|is|are|been|being)\\s+\\w+ed\\b/gi) || []\n  \n  return {\n    complexWords: {\n      count: complexWords.length,\n      percentage: Math.round((complexWords.length / words.length) * 100),\n      examples: complexWords.slice(0, 5)\n    },\n    longWords: {\n      count: longWords.length,\n      percentage: Math.round((longWords.length / words.length) * 100),\n      examples: longWords.slice(0, 5)\n    },\n    veryLongWords: {\n      count: veryLongWords.length,\n      examples: veryLongWords.slice(0, 3)\n    },\n    longSentences: {\n      count: longSentences.length,\n      percentage: Math.round((longSentences.length / sentences.length) * 100)\n    },\n    veryLongSentences: {\n      count: veryLongSentences.length,\n      examples: veryLongSentences.slice(0, 2).map(s => s.trim().substring(0, 100) + '...')\n    },\n    technicalTerms: {\n      count: technicalTerms.length,\n      examples: technicalTerms.slice(0, 5)\n    },\n    acronyms: {\n      count: acronyms.length,\n      examples: [...new Set(acronyms)].slice(0, 5)\n    },\n    passiveVoice: {\n      count: passiveVoiceMatches.length,\n      percentage: Math.round((passiveVoiceMatches.length / sentences.length) * 100)\n    }\n  }\n}\n\n/**\n * Analyze text structure for accessibility\n */\nfunction analyzeStructure(text: string) {\n  const paragraphs = text.split(/\\n\\s*\\n/).filter(p => p.trim().length > 0)\n  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0)\n  \n  // Check for speech-specific markers\n  const pauseMarkers = (text.match(/\\[PAUSE\\]/g) || []).length\n  const emphasisMarkers = (text.match(/\\[EMPHASIZE\\]/g) || []).length\n  const callbackMarkers = (text.match(/\\[CALLBACK:[^\\]]+\\]/g) || []).length\n  \n  // Transition words and phrases\n  const transitionWords = [\n    'however', 'therefore', 'furthermore', 'moreover', 'consequently',\n    'in addition', 'on the other hand', 'for example', 'in conclusion',\n    'first', 'second', 'third', 'finally', 'next', 'then'\n  ]\n  \n  const transitionsFound = transitionWords.filter(word => \n    text.toLowerCase().includes(word.toLowerCase())\n  )\n  \n  return {\n    paragraphs: {\n      count: paragraphs.length,\n      avgSentencesPerParagraph: Math.round((sentences.length / paragraphs.length) * 10) / 10\n    },\n    speechMarkers: {\n      pauses: pauseMarkers,\n      emphasis: emphasisMarkers,\n      callbacks: callbackMarkers,\n      total: pauseMarkers + emphasisMarkers + callbackMarkers\n    },\n    transitions: {\n      count: transitionsFound.length,\n      examples: transitionsFound.slice(0, 5),\n      density: Math.round((transitionsFound.length / sentences.length) * 100)\n    },\n    flow: {\n      hasIntroduction: text.toLowerCase().includes('today') || text.toLowerCase().includes('welcome'),\n      hasConclusion: text.toLowerCase().includes('conclusion') || text.toLowerCase().includes('finally'),\n      hasCallToAction: text.toLowerCase().includes('action') || text.toLowerCase().includes('do')\n    }\n  }\n}\n\n/**\n * Generate AI-powered suggestions for improvement\n */\nasync function generateAISuggestions(text: string, targetLevel?: string, readabilityScores?: any) {\n  const prompt = `\nAnalyze this speech text for accessibility and readability improvements:\n\n\"${text}\"\n\n${targetLevel ? `Target Audience Level: ${targetLevel}` : ''}\n${readabilityScores ? `Current Flesch Reading Ease: ${readabilityScores.fleschReadingEase}` : ''}\n${readabilityScores ? `Current Grade Level: ${readabilityScores.fleschKincaidGrade}` : ''}\n\nProvide specific suggestions to improve accessibility and comprehension:\n\n1. Identify complex sentences that should be simplified\n2. Suggest replacements for difficult words\n3. Recommend structural improvements\n4. Highlight areas that need better transitions\n5. Suggest where to add pauses or emphasis for spoken delivery\n\nReturn your analysis as JSON:\n{\n  \"complexSentences\": [\n    {\n      \"original\": \"complex sentence\",\n      \"simplified\": \"simpler version\",\n      \"reason\": \"why it needed simplification\"\n    }\n  ],\n  \"wordReplacements\": [\n    {\n      \"original\": \"difficult word\",\n      \"replacement\": \"simpler alternative\",\n      \"context\": \"surrounding context\"\n    }\n  ],\n  \"structuralImprovements\": [\n    \"suggestion 1\",\n    \"suggestion 2\"\n  ],\n  \"deliveryTips\": [\n    \"tip for spoken delivery\"\n  ],\n  \"overallRecommendation\": \"summary of main improvements needed\"\n}`\n\n  try {\n    const response = await robustAICall(\n      [\n        {\n          role: 'system',\n          content: 'You are an accessibility expert and plain language specialist. Help make speech content more accessible and easier to understand for diverse audiences.'\n        },\n        {\n          role: 'user',\n          content: prompt\n        }\n      ],\n      {\n        model: 'gpt-4',\n        temperature: 0.3,\n        maxTokens: 1500\n      }\n    )\n\n    if (response.success) {\n      try {\n        return JSON.parse(response.content)\n      } catch (parseError) {\n        console.error('Failed to parse AI suggestions:', parseError)\n        return null\n      }\n    }\n  } catch (error) {\n    console.error('AI suggestions failed:', error)\n  }\n  \n  return null\n}\n\n/**\n * Generate overall accessibility assessment\n */\nfunction generateOverallAssessment(readability: any, complexity: any, structure: any, targetLevel?: string) {\n  const issues = []\n  const strengths = []\n  \n  // Readability assessment\n  if (readability.fleschReadingEase < 30) {\n    issues.push('Text is very difficult to read (Flesch score < 30)')\n  } else if (readability.fleschReadingEase < 50) {\n    issues.push('Text is fairly difficult to read')\n  } else if (readability.fleschReadingEase > 70) {\n    strengths.push('Text has good readability')\n  }\n  \n  // Grade level assessment\n  const targetGrades = {\n    'elementary': 5,\n    'middle': 8,\n    'high-school': 12,\n    'college': 16,\n    'graduate': 18,\n    'professional': 20\n  }\n  \n  const targetGrade = targetLevel ? targetGrades[targetLevel] : 12\n  if (readability.fleschKincaidGrade > targetGrade + 2) {\n    issues.push(`Grade level (${readability.fleschKincaidGrade}) is too high for target audience`)\n  }\n  \n  // Complexity assessment\n  if (complexity.complexWords.percentage > 15) {\n    issues.push(`High percentage of complex words (${complexity.complexWords.percentage}%)`)\n  }\n  \n  if (complexity.longSentences.percentage > 30) {\n    issues.push(`Many long sentences (${complexity.longSentences.percentage}%)`)\n  }\n  \n  if (complexity.passiveVoice.percentage > 20) {\n    issues.push(`High use of passive voice (${complexity.passiveVoice.percentage}%)`)\n  }\n  \n  // Structure assessment\n  if (structure.transitions.density < 5) {\n    issues.push('Few transition words - may be hard to follow')\n  } else {\n    strengths.push('Good use of transition words')\n  }\n  \n  if (structure.speechMarkers.total > 0) {\n    strengths.push('Includes helpful speech delivery markers')\n  }\n  \n  return {\n    overallScore: calculateAccessibilityScore(readability, complexity, structure),\n    level: determineAccessibilityLevel(issues.length, strengths.length),\n    issues,\n    strengths,\n    suitableFor: determineSuitableAudience(readability.fleschKincaidGrade)\n  }\n}\n\n/**\n * Generate specific recommendations\n */\nfunction generateRecommendations(assessment: any, targetLevel?: string) {\n  const recommendations = []\n  \n  if (assessment.issues.length === 0) {\n    recommendations.push('Text meets accessibility standards for the target audience')\n  } else {\n    recommendations.push('Consider the following improvements:')\n    assessment.issues.forEach((issue: string) => {\n      if (issue.includes('complex words')) {\n        recommendations.push('• Replace complex words with simpler alternatives')\n      } else if (issue.includes('long sentences')) {\n        recommendations.push('• Break long sentences into shorter ones')\n      } else if (issue.includes('passive voice')) {\n        recommendations.push('• Convert passive voice to active voice where possible')\n      } else if (issue.includes('grade level')) {\n        recommendations.push('• Simplify vocabulary and sentence structure')\n      } else if (issue.includes('transition')) {\n        recommendations.push('• Add more transition words to improve flow')\n      }\n    })\n  }\n  \n  recommendations.push('• Test the speech with members of your target audience')\n  recommendations.push('• Consider adding visual aids to support comprehension')\n  recommendations.push('• Practice delivery with appropriate pacing and emphasis')\n  \n  return recommendations\n}\n\n/**\n * Count syllables in a word (simplified algorithm)\n */\nfunction countSyllables(word: string): number {\n  word = word.toLowerCase()\n  if (word.length <= 3) return 1\n  \n  const vowels = 'aeiouy'\n  let syllableCount = 0\n  let previousWasVowel = false\n  \n  for (let i = 0; i < word.length; i++) {\n    const isVowel = vowels.includes(word[i])\n    if (isVowel && !previousWasVowel) {\n      syllableCount++\n    }\n    previousWasVowel = isVowel\n  }\n  \n  // Handle silent 'e'\n  if (word.endsWith('e')) {\n    syllableCount--\n  }\n  \n  return Math.max(1, syllableCount)\n}\n\n/**\n * Detect technical terms (basic implementation)\n */\nfunction detectTechnicalTerms(text: string): string[] {\n  const technicalPatterns = [\n    /\\b\\w+ology\\b/gi,\n    /\\b\\w+ism\\b/gi,\n    /\\b\\w+tion\\b/gi,\n    /\\b\\w+ment\\b/gi,\n    /\\b\\w{10,}\\b/gi // Very long words often technical\n  ]\n  \n  const terms = new Set<string>()\n  \n  technicalPatterns.forEach(pattern => {\n    const matches = text.match(pattern) || []\n    matches.forEach(match => terms.add(match.toLowerCase()))\n  })\n  \n  return Array.from(terms)\n}\n\n/**\n * Calculate overall accessibility score (0-100)\n */\nfunction calculateAccessibilityScore(readability: any, complexity: any, structure: any): number {\n  let score = 100\n  \n  // Readability penalties\n  if (readability.fleschReadingEase < 30) score -= 30\n  else if (readability.fleschReadingEase < 50) score -= 15\n  \n  // Complexity penalties\n  if (complexity.complexWords.percentage > 15) score -= 20\n  if (complexity.longSentences.percentage > 30) score -= 15\n  if (complexity.passiveVoice.percentage > 20) score -= 10\n  \n  // Structure bonuses/penalties\n  if (structure.transitions.density < 5) score -= 10\n  if (structure.speechMarkers.total > 0) score += 5\n  \n  return Math.max(0, Math.min(100, score))\n}\n\n/**\n * Determine accessibility level\n */\nfunction determineAccessibilityLevel(issueCount: number, strengthCount: number): string {\n  if (issueCount === 0) return 'excellent'\n  if (issueCount <= 2 && strengthCount >= 2) return 'good'\n  if (issueCount <= 4) return 'fair'\n  return 'needs improvement'\n}\n\n/**\n * Determine suitable audience based on grade level\n */\nfunction determineSuitableAudience(gradeLevel: number): string[] {\n  const audiences = []\n  \n  if (gradeLevel <= 6) audiences.push('elementary school')\n  if (gradeLevel <= 9) audiences.push('middle school')\n  if (gradeLevel <= 13) audiences.push('high school', 'general public')\n  if (gradeLevel <= 16) audiences.push('college students')\n  if (gradeLevel <= 18) audiences.push('graduate students')\n  audiences.push('professionals', 'experts')\n  \n  return audiences\n}\n\nexport { handler }"