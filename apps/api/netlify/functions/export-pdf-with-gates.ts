import { Handler, HandlerEvent, HandlerContext } from '@netlify/functions';
import { z } from 'zod';
import puppeteer from 'puppeteer';
import { drizzle } from 'drizzle-orm/postgres-js';
import { eq, and } from 'drizzle-orm';
import postgres from 'postgres';
import { speeches, speechSections, users, subscriptions } from '@speechwriter/database/schema';
import jwt from 'jsonwebtoken';
import { validateExportPermissions } from './lib/export-gate-utils';
import { serverAnalytics, ANALYTICS_EVENTS } from '@speechwriter/analytics';
import type { ApiResponse } from '@speechwriter/config';

const client = postgres(process.env.DATABASE_URL!, { prepare: false });
const db = drizzle(client, { schema: { speeches, speechSections, users, subscriptions } });

// Request validation schema
const exportPdfSchema = z.object({
  speechId: z.string().uuid(),
  format: z.enum(['speaker-notes', 'full-script', 'outline-only']).default('full-script'),
  includeStageDirections: z.boolean().default(true),
  includeTiming: z.boolean().default(true),
  overrideQualityGate: z.boolean().default(false), // Admin override
});

// JWT verification for auth
const verifyToken = (token: string) => {
  try {
    return jwt.verify(token, process.env.NEXTAUTH_SECRET!);
  } catch {
    return null;
  }
};

// PDF generation using Puppeteer (same as before)
const generatePDF = async (htmlContent: string, options: any): Promise<Buffer> => {
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  
  try {
    const page = await browser.newPage();
    await page.setContent(htmlContent, { waitUntil: 'networkidle0' });
    
    const pdfBuffer = await page.pdf({
      format: 'A4',
      printBackground: true,
      margin: {
        top: '1in',
        right: '0.75in',
        bottom: '1in',
        left: '0.75in'
      },
      ...options
    });
    
    return pdfBuffer as Buffer;
  } finally {
    await browser.close();
  }
};

// Generate HTML template with quality warnings
const generateSpeechHTML = (
  speech: any, 
  options: any, 
  qualityValidation?: any
): string => {
  const { format, includeStageDirections, includeTiming, watermark } = options;
  
  // Quality warnings section
  const qualityWarningsHTML = qualityValidation?.warnings?.length > 0 ? `
    <div class="quality-warnings">
      <h3>⚠️ Quality Notices</h3>
      <div class="warnings-list">
        ${qualityValidation.warnings.map((warning: any) => `
          <div class="warning-item">
            <strong>${warning.title}</strong>
            <p>${warning.description}</p>
            ${warning.flaggedText ? `<blockquote>"${warning.flaggedText}"</blockquote>` : ''}
          </div>
        `).join('')}
      </div>
    </div>
  ` : '';
  
  // Format stage directions like [PAUSE], [EMPHASIZE], [CALLBACK]
  const formatStageDirections = (text: string): string => {
    if (!includeStageDirections) {
      return text.replace(/\[([A-Z]+)\]/g, '');
    }
    
    return text.replace(/\[([A-Z]+)\]/g, '<span class="stage-direction">[$1]</span>');
  };
  
  // Format timing information
  const formatTiming = (section: any): string => {
    if (!includeTiming) return '';
    const allocated = section.allocatedTimeMinutes || 0;
    const actual = section.actualTimeMinutes || 0;
    return `<div class="timing">Target: ${allocated}min${actual ? ` | Actual: ${actual}min` : ''}</div>`;
  };
  
  const watermarkHTML = watermark ? `
    <div class="watermark">
      <div class="watermark-text">
        Generated by SpeechWriter.ai - Free Plan<br>
        Upgrade for clean exports
      </div>
    </div>
  ` : '';
  
  const sectionsHTML = speech.sections?.map((section: any, index: number) => `
    <div class="section">
      <h2 class="section-title">${section.title}</h2>
      ${formatTiming(section)}
      <div class="section-content">
        ${formatStageDirections(section.content || '')}
      </div>
    </div>
  `).join('') || '';
  
  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${speech.title}</title>
      <style>
        body {
          font-family: 'Georgia', 'Times New Roman', serif;
          line-height: 1.6;
          color: #333;
          max-width: 8.5in;
          margin: 0 auto;
          padding: 0;
          position: relative;
        }
        
        .header {
          text-align: center;
          margin-bottom: 2rem;
          border-bottom: 2px solid #333;
          padding-bottom: 1rem;
        }
        
        .speech-title {
          font-size: 2rem;
          font-weight: bold;
          margin: 0;
          color: #2c3e50;
        }
        
        .speech-meta {
          font-size: 1rem;
          color: #666;
          margin-top: 0.5rem;
        }
        
        .quality-warnings {
          background: #fef7e0;
          border: 1px solid #f59e0b;
          border-radius: 8px;
          padding: 1rem;
          margin: 2rem 0;
        }
        
        .quality-warnings h3 {
          color: #f59e0b;
          margin: 0 0 1rem 0;
          font-size: 1.2rem;
        }
        
        .warning-item {
          margin-bottom: 1rem;
          padding: 0.5rem;
          background: white;
          border-radius: 4px;
        }
        
        .warning-item strong {
          color: #92400e;
        }
        
        .warning-item blockquote {
          background: #f3f4f6;
          border-left: 3px solid #f59e0b;
          margin: 0.5rem 0;
          padding: 0.5rem 1rem;
          font-style: italic;
        }
        
        .section {
          margin-bottom: 2rem;
          page-break-inside: avoid;
        }
        
        .section-title {
          font-size: 1.3rem;
          font-weight: bold;
          color: #2c3e50;
          border-left: 4px solid #3498db;
          padding-left: 1rem;
          margin-bottom: 0.5rem;
        }
        
        .timing {
          font-size: 0.9rem;
          color: #7f8c8d;
          margin-bottom: 1rem;
          font-style: italic;
        }
        
        .section-content {
          font-size: 1.1rem;
          line-height: 1.8;
          text-align: justify;
        }
        
        .stage-direction {
          color: #e74c3c;
          font-weight: bold;
          font-family: 'Arial', sans-serif;
          font-size: 0.9em;
          text-transform: uppercase;
        }
        
        .watermark {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%) rotate(-45deg);
          z-index: -1;
          opacity: 0.1;
        }
        
        .watermark-text {
          font-size: 2rem;
          font-weight: bold;
          color: #999;
          text-align: center;
          white-space: nowrap;
        }
        
        .footer {
          margin-top: 3rem;
          padding-top: 1rem;
          border-top: 1px solid #ddd;
          font-size: 0.9rem;
          color: #666;
          text-align: center;
        }
        
        @media print {
          body {
            margin: 0;
            padding: 1rem;
          }
          
          .section {
            page-break-inside: avoid;
          }
        }
      </style>
    </head>
    <body>
      ${watermarkHTML}
      
      <div class="header">
        <h1 class="speech-title">${speech.title}</h1>
        <div class="speech-meta">
          <strong>Occasion:</strong> ${speech.occasion}<br>
          <strong>Audience:</strong> ${speech.audience}<br>
          <strong>Target Duration:</strong> ${speech.targetDurationMinutes} minutes
        </div>
      </div>
      
      ${qualityWarningsHTML}
      
      <div class="content">
        ${sectionsHTML}
      </div>
      
      <div class="footer">
        Generated on ${new Date().toLocaleDateString()} | SpeechWriter.ai
        ${qualityValidation?.warnings?.length > 0 ? '<br><em>This speech contains quality notices - please review before presenting</em>' : ''}
      </div>
    </body>
    </html>
  `;
};

const handler: Handler = async (event: HandlerEvent, context: HandlerContext) => {
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  };

  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers,
      body: '',
    };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({
        success: false,
        error: {
          message: 'Method not allowed',
          code: 'METHOD_NOT_ALLOWED',
        },
        timestamp: new Date().toISOString(),
      } as ApiResponse),
    };
  }

  try {
    // Verify authentication
    const authHeader = event.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return {
        statusCode: 401,
        headers,
        body: JSON.stringify({
          success: false,
          error: {
            message: 'Unauthorized',
            code: 'UNAUTHORIZED',
          },
          timestamp: new Date().toISOString(),
        } as ApiResponse),
      };
    }

    const token = authHeader.replace('Bearer ', '');
    const decoded = verifyToken(token) as any;
    if (!decoded?.sub) {
      return {
        statusCode: 401,
        headers,
        body: JSON.stringify({
          success: false,
          error: {
            message: 'Invalid token',
            code: 'INVALID_TOKEN',
          },
          timestamp: new Date().toISOString(),
        } as ApiResponse),
      };
    }

    const userId = decoded.sub;
    
    // Parse and validate request body
    const body = JSON.parse(event.body || '{}');
    const validatedData = exportPdfSchema.parse(body);
    const { speechId, overrideQualityGate } = validatedData;

    // Get speech data from database
    const [speech] = await db
      .select()
      .from(speeches)
      .where(
        and(
          eq(speeches.id, speechId),
          eq(speeches.userId, userId)
        )
      )
      .limit(1);

    if (!speech) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({
          success: false,
          error: {
            message: 'Speech not found',
            code: 'SPEECH_NOT_FOUND',
          },
          timestamp: new Date().toISOString(),
        } as ApiResponse),
      };
    }

    // Get speech sections
    const sections = await db
      .select()
      .from(speechSections)
      .where(eq(speechSections.speechId, speechId));

    // QUALITY GATE: Validate export permissions
    const qualityValidation = await validateExportPermissions(speechId, userId);
    
    if (!qualityValidation.canExport && !overrideQualityGate) {
      return {
        statusCode: 423, // Locked
        headers,
        body: JSON.stringify({
          success: false,
          error: {
            message: 'Export blocked due to quality issues',
            code: 'EXPORT_BLOCKED',
            details: {
              blockingIssues: qualityValidation.blockingIssues.length,
              totalIssues: qualityValidation.totalIssues,
              issues: qualityValidation.blockingIssues.map(issue => ({
                type: issue.issueType,
                severity: issue.severity,
                title: issue.title,
                description: issue.description,
              })),
            },
          },
          timestamp: new Date().toISOString(),
        } as ApiResponse),
      };
    }

    // Get user subscription for watermark decision
    const [userSubscription] = await db
      .select({
        plan: subscriptions.plan,
      })
      .from(subscriptions)
      .where(eq(subscriptions.userId, userId))
      .limit(1);

    const shouldWatermark = !userSubscription || userSubscription.plan === 'free';
    
    const fullSpeech = {
      ...speech,
      sections,
    };

    // Generate HTML content
    const htmlContent = generateSpeechHTML(
      fullSpeech, 
      {
        ...validatedData,
        watermark: shouldWatermark,
      },
      qualityValidation
    );

    // Generate PDF
    const pdfBuffer = await generatePDF(htmlContent, {
      displayHeaderFooter: true,
      headerTemplate: '<div></div>',
      footerTemplate: '<div style="font-size: 10px; text-align: center; width: 100%;">Page <span class="pageNumber"></span> of <span class="totalPages"></span></div>'
    });

    // Track successful export
    await serverAnalytics.track(userId, ANALYTICS_EVENTS.EXPORT_COMPLETED, {
      speech_id: speechId,
      format: validatedData.format,
      has_quality_warnings: qualityValidation.warnings.length > 0,
      quality_override_used: overrideQualityGate,
    });

    // Return PDF as base64
    const base64Pdf = pdfBuffer.toString('base64');
    
    return {
      statusCode: 200,
      headers: {
        ...headers,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        success: true,
        data: {
          filename: `${speech.title.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`,
          content: base64Pdf,
          size: pdfBuffer.length,
          format: validatedData.format,
          qualityInfo: {
            hasWarnings: qualityValidation.warnings.length > 0,
            warningsCount: qualityValidation.warnings.length,
            wasBlocked: !qualityValidation.canExport,
            overrideUsed: overrideQualityGate,
          },
        },
        timestamp: new Date().toISOString(),
      } as ApiResponse),
    };

  } catch (error) {
    console.error('Error generating PDF:', error);

    const errorResponse: ApiResponse = {
      success: false,
      error: {
        message: error instanceof Error ? error.message : 'PDF generation failed',
        code: 'PDF_GENERATION_ERROR',
        details: error instanceof z.ZodError ? error.errors : undefined,
      },
      timestamp: new Date().toISOString(),
    };

    return {
      statusCode: error instanceof z.ZodError ? 400 : 500,
      headers,
      body: JSON.stringify(errorResponse),
    };
  }
};

export { handler };