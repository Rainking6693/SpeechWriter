import { Handler, HandlerEvent } from '@netlify/functions'\nimport { z } from 'zod'\nimport { drizzle } from 'drizzle-orm/postgres-js'\nimport { eq, and } from 'drizzle-orm'\nimport postgres from 'postgres'\nimport { users, dataExportRequests, dataDeletionRequests, consentRecords } from '@speechwriter/database/schema'\nimport jwt from 'jsonwebtoken'\nimport { v4 as uuidv4 } from 'uuid'\nimport { trackError } from './lib/error-tracking'\n\nconst client = postgres(process.env.DATABASE_URL!, { prepare: false })\nconst db = drizzle(client, { schema: { users, dataExportRequests, dataDeletionRequests, consentRecords } })\n\nconst privacyRequestSchema = z.object({\n  type: z.enum(['export', 'delete', 'consent']),\n  email: z.string().email().optional(),\n  reason: z.string().optional(),\n  consentTypes: z.array(z.string()).optional(),\n  consentGiven: z.boolean().optional()\n})\n\nconst verifyToken = (token: string) => {\n  try {\n    return jwt.verify(token, process.env.NEXTAUTH_SECRET!)\n  } catch {\n    return null\n  }\n}\n\nconst handler: Handler = async (event: HandlerEvent) => {\n  if (event.httpMethod === 'OPTIONS') {\n    return {\n      statusCode: 200,\n      headers: {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n        'Access-Control-Allow-Methods': 'POST, GET, DELETE'\n      },\n      body: ''\n    }\n  }\n\n  try {\n    const authHeader = event.headers.authorization\n    let userId: string | null = null\n    \n    // For some privacy requests, authentication might not be required (e.g., deletion by email)\n    if (authHeader?.startsWith('Bearer ')) {\n      const token = authHeader.replace('Bearer ', '')\n      const decoded = verifyToken(token) as any\n      userId = decoded?.sub || null\n    }\n\n    if (event.httpMethod === 'POST') {\n      return await handlePrivacyRequest(event, userId)\n    }\n\n    if (event.httpMethod === 'GET') {\n      return await handlePrivacyDataRequest(event, userId)\n    }\n\n    if (event.httpMethod === 'DELETE') {\n      return await handleDataDeletion(event, userId)\n    }\n\n    return {\n      statusCode: 405,\n      body: JSON.stringify({ error: 'Method not allowed' })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'privacy-compliance',\n      additionalData: { method: event.httpMethod }\n    })\n    \n    return {\n      statusCode: 500,\n      body: JSON.stringify({ \n        error: 'Privacy request failed',\n        details: process.env.NODE_ENV === 'development' ? error.message : undefined\n      })\n    }\n  }\n}\n\n/**\n * Handle privacy requests (export, delete, consent)\n */\nasync function handlePrivacyRequest(event: HandlerEvent, userId: string | null) {\n  const body = JSON.parse(event.body || '{}')\n  const { type, email, reason, consentTypes, consentGiven } = privacyRequestSchema.parse(body)\n\n  switch (type) {\n    case 'export':\n      return await handleDataExportRequest(userId, email, reason)\n    \n    case 'delete':\n      return await handleDataDeletionRequest(userId, email, reason)\n    \n    case 'consent':\n      return await handleConsentUpdate(userId, consentTypes, consentGiven)\n    \n    default:\n      return {\n        statusCode: 400,\n        body: JSON.stringify({ error: 'Invalid request type' })\n      }\n  }\n}\n\n/**\n * Handle data export requests (GDPR Article 15, CCPA)\n */\nasync function handleDataExportRequest(userId: string | null, email?: string, reason?: string) {\n  try {\n    // Find user by ID or email\n    let user\n    if (userId) {\n      [user] = await db.select().from(users).where(eq(users.id, userId)).limit(1)\n    } else if (email) {\n      [user] = await db.select().from(users).where(eq(users.email, email)).limit(1)\n    } else {\n      return {\n        statusCode: 400,\n        body: JSON.stringify({ error: 'User ID or email required' })\n      }\n    }\n\n    if (!user) {\n      return {\n        statusCode: 404,\n        body: JSON.stringify({ error: 'User not found' })\n      }\n    }\n\n    // Check for existing pending requests\n    const existingRequest = await db\n      .select()\n      .from(dataExportRequests)\n      .where(\n        and(\n          eq(dataExportRequests.userId, user.id),\n          eq(dataExportRequests.status, 'pending')\n        )\n      )\n      .limit(1)\n\n    if (existingRequest.length > 0) {\n      return {\n        statusCode: 409,\n        body: JSON.stringify({ \n          error: 'Export request already pending',\n          requestId: existingRequest[0].id\n        })\n      }\n    }\n\n    // Create export request\n    const [exportRequest] = await db\n      .insert(dataExportRequests)\n      .values({\n        id: uuidv4(),\n        userId: user.id,\n        email: user.email,\n        reason: reason || null,\n        status: 'pending',\n        requestedAt: new Date(),\n        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days\n      })\n      .returning()\n\n    // Start background export process\n    await initiateDataExport(exportRequest.id, user.id)\n\n    return {\n      statusCode: 202,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        message: 'Data export request submitted',\n        requestId: exportRequest.id,\n        estimatedCompletion: '24-48 hours',\n        expiresAt: exportRequest.expiresAt\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'privacy-compliance',\n      userId,\n      additionalData: { action: 'data_export' }\n    })\n    throw error\n  }\n}\n\n/**\n * Handle data deletion requests (GDPR Article 17, CCPA)\n */\nasync function handleDataDeletionRequest(userId: string | null, email?: string, reason?: string) {\n  try {\n    // Find user by ID or email\n    let user\n    if (userId) {\n      [user] = await db.select().from(users).where(eq(users.id, userId)).limit(1)\n    } else if (email) {\n      [user] = await db.select().from(users).where(eq(users.email, email)).limit(1)\n    } else {\n      return {\n        statusCode: 400,\n        body: JSON.stringify({ error: 'User ID or email required' })\n      }\n    }\n\n    if (!user) {\n      return {\n        statusCode: 404,\n        body: JSON.stringify({ error: 'User not found' })\n      }\n    }\n\n    // Check for existing pending requests\n    const existingRequest = await db\n      .select()\n      .from(dataDeletionRequests)\n      .where(\n        and(\n          eq(dataDeletionRequests.userId, user.id),\n          eq(dataDeletionRequests.status, 'pending')\n        )\n      )\n      .limit(1)\n\n    if (existingRequest.length > 0) {\n      return {\n        statusCode: 409,\n        body: JSON.stringify({ \n          error: 'Deletion request already pending',\n          requestId: existingRequest[0].id\n        })\n      }\n    }\n\n    // Create deletion request with grace period\n    const [deletionRequest] = await db\n      .insert(dataDeletionRequests)\n      .values({\n        id: uuidv4(),\n        userId: user.id,\n        email: user.email,\n        reason: reason || null,\n        status: 'pending',\n        requestedAt: new Date(),\n        scheduledDeletionAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30-day grace period\n      })\n      .returning()\n\n    // Send confirmation email (implement email service)\n    await sendDeletionConfirmationEmail(user.email, deletionRequest.id)\n\n    return {\n      statusCode: 202,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        message: 'Data deletion request submitted',\n        requestId: deletionRequest.id,\n        gracePeriod: '30 days',\n        scheduledDeletionAt: deletionRequest.scheduledDeletionAt,\n        cancellationInfo: 'You can cancel this request within 30 days by contacting support'\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'privacy-compliance',\n      userId,\n      additionalData: { action: 'data_deletion' }\n    })\n    throw error\n  }\n}\n\n/**\n * Handle consent updates\n */\nasync function handleConsentUpdate(userId: string | null, consentTypes?: string[], consentGiven?: boolean) {\n  if (!userId) {\n    return {\n      statusCode: 401,\n      body: JSON.stringify({ error: 'Authentication required for consent updates' })\n    }\n  }\n\n  if (!consentTypes || consentGiven === undefined) {\n    return {\n      statusCode: 400,\n      body: JSON.stringify({ error: 'Consent types and consent status required' })\n    }\n  }\n\n  try {\n    // Record consent for each type\n    const consentRecordsToInsert = consentTypes.map(type => ({\n      id: uuidv4(),\n      userId,\n      consentType: type,\n      consentGiven,\n      consentDate: new Date(),\n      ipAddress: null, // Could be extracted from headers\n      userAgent: null  // Could be extracted from headers\n    }))\n\n    await db.insert(consentRecords).values(consentRecordsToInsert)\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        message: 'Consent preferences updated',\n        consentTypes,\n        consentGiven,\n        recordedAt: new Date().toISOString()\n      })\n    }\n\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'privacy-compliance',\n      userId,\n      additionalData: { action: 'consent_update' }\n    })\n    throw error\n  }\n}\n\n/**\n * Handle privacy data requests (GET)\n */\nasync function handlePrivacyDataRequest(event: HandlerEvent, userId: string | null) {\n  if (!userId) {\n    return {\n      statusCode: 401,\n      body: JSON.stringify({ error: 'Authentication required' })\n    }\n  }\n\n  const requestType = event.queryStringParameters?.type\n\n  try {\n    switch (requestType) {\n      case 'export-status':\n        return await getExportRequestStatus(userId)\n      \n      case 'deletion-status':\n        return await getDeletionRequestStatus(userId)\n      \n      case 'consent-history':\n        return await getConsentHistory(userId)\n      \n      case 'privacy-summary':\n        return await getPrivacySummary(userId)\n      \n      default:\n        return {\n          statusCode: 400,\n          body: JSON.stringify({ error: 'Invalid request type' })\n        }\n    }\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'privacy-compliance',\n      userId,\n      additionalData: { action: 'privacy_data_request', type: requestType }\n    })\n    throw error\n  }\n}\n\n/**\n * Initiate background data export process\n */\nasync function initiateDataExport(requestId: string, userId: string) {\n  try {\n    // This would typically trigger a background job\n    // For now, we'll just update the status\n    await db\n      .update(dataExportRequests)\n      .set({ status: 'processing' })\n      .where(eq(dataExportRequests.id, requestId))\n\n    // In a real implementation, you would:\n    // 1. Queue a background job\n    // 2. Collect all user data from all tables\n    // 3. Generate a comprehensive export file\n    // 4. Upload to secure storage\n    // 5. Send download link to user\n    // 6. Set expiration for the download link\n\n    console.log(`Data export initiated for user ${userId}, request ${requestId}`)\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'privacy-compliance',\n      userId,\n      additionalData: { action: 'initiate_export', requestId }\n    })\n  }\n}\n\n/**\n * Send deletion confirmation email\n */\nasync function sendDeletionConfirmationEmail(email: string, requestId: string) {\n  try {\n    // Implement email service integration\n    console.log(`Deletion confirmation email sent to ${email} for request ${requestId}`)\n    \n    // In a real implementation:\n    // 1. Use email service (SendGrid, Resend, etc.)\n    // 2. Send confirmation with cancellation link\n    // 3. Include information about what will be deleted\n    // 4. Provide contact information for questions\n  } catch (error) {\n    await trackError(error as Error, {\n      functionName: 'privacy-compliance',\n      additionalData: { action: 'send_deletion_email', email, requestId }\n    })\n  }\n}\n\n/**\n * Get export request status\n */\nasync function getExportRequestStatus(userId: string) {\n  const requests = await db\n    .select()\n    .from(dataExportRequests)\n    .where(eq(dataExportRequests.userId, userId))\n    .orderBy(desc(dataExportRequests.requestedAt))\n    .limit(10)\n\n  return {\n    statusCode: 200,\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*'\n    },\n    body: JSON.stringify({\n      requests: requests.map(req => ({\n        id: req.id,\n        status: req.status,\n        requestedAt: req.requestedAt,\n        completedAt: req.completedAt,\n        expiresAt: req.expiresAt,\n        downloadUrl: req.downloadUrl\n      }))\n    })\n  }\n}\n\n/**\n * Get deletion request status\n */\nasync function getDeletionRequestStatus(userId: string) {\n  const requests = await db\n    .select()\n    .from(dataDeletionRequests)\n    .where(eq(dataDeletionRequests.userId, userId))\n    .orderBy(desc(dataDeletionRequests.requestedAt))\n    .limit(10)\n\n  return {\n    statusCode: 200,\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*'\n    },\n    body: JSON.stringify({\n      requests: requests.map(req => ({\n        id: req.id,\n        status: req.status,\n        requestedAt: req.requestedAt,\n        scheduledDeletionAt: req.scheduledDeletionAt,\n        completedAt: req.completedAt,\n        canCancel: req.status === 'pending' && new Date() < new Date(req.scheduledDeletionAt)\n      }))\n    })\n  }\n}\n\n/**\n * Get consent history\n */\nasync function getConsentHistory(userId: string) {\n  const consents = await db\n    .select()\n    .from(consentRecords)\n    .where(eq(consentRecords.userId, userId))\n    .orderBy(desc(consentRecords.consentDate))\n    .limit(50)\n\n  return {\n    statusCode: 200,\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*'\n    },\n    body: JSON.stringify({\n      consents: consents.map(consent => ({\n        consentType: consent.consentType,\n        consentGiven: consent.consentGiven,\n        consentDate: consent.consentDate\n      }))\n    })\n  }\n}\n\n/**\n * Get privacy summary\n */\nasync function getPrivacySummary(userId: string) {\n  const [user] = await db.select().from(users).where(eq(users.id, userId)).limit(1)\n  \n  if (!user) {\n    return {\n      statusCode: 404,\n      body: JSON.stringify({ error: 'User not found' })\n    }\n  }\n\n  // Get latest consent records\n  const latestConsents = await db\n    .select()\n    .from(consentRecords)\n    .where(eq(consentRecords.userId, userId))\n    .orderBy(desc(consentRecords.consentDate))\n    .limit(10)\n\n  // Get pending requests\n  const pendingExports = await db\n    .select()\n    .from(dataExportRequests)\n    .where(\n      and(\n        eq(dataExportRequests.userId, userId),\n        eq(dataExportRequests.status, 'pending')\n      )\n    )\n\n  const pendingDeletions = await db\n    .select()\n    .from(dataDeletionRequests)\n    .where(\n      and(\n        eq(dataDeletionRequests.userId, userId),\n        eq(dataDeletionRequests.status, 'pending')\n      )\n    )\n\n  return {\n    statusCode: 200,\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*'\n    },\n    body: JSON.stringify({\n      user: {\n        id: user.id,\n        email: user.email,\n        createdAt: user.createdAt,\n        lastLoginAt: user.lastLoginAt\n      },\n      privacy: {\n        dataRetentionPeriod: '7 years after account deletion',\n        encryptionStatus: 'AES-256 encryption at rest',\n        dataProcessingBasis: 'Consent and legitimate interest',\n        thirdPartySharing: 'Limited to essential service providers'\n      },\n      consents: latestConsents.map(c => ({\n        type: c.consentType,\n        given: c.consentGiven,\n        date: c.consentDate\n      })),\n      pendingRequests: {\n        exports: pendingExports.length,\n        deletions: pendingDeletions.length\n      },\n      rights: {\n        access: 'Request a copy of your personal data',\n        rectification: 'Request correction of inaccurate data',\n        erasure: 'Request deletion of your personal data',\n        portability: 'Request data in a machine-readable format',\n        objection: 'Object to processing of your personal data',\n        restriction: 'Request restriction of processing'\n      }\n    })\n  }\n}\n\nexport { handler }"