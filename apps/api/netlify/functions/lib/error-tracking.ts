import * as Sentry from '@sentry/node'\nimport { drizzle } from 'drizzle-orm/postgres-js'\nimport postgres from 'postgres'\nimport { errorLogs } from '@speechwriter/database/schema'\nimport { v4 as uuidv4 } from 'uuid'\n\nconst client = postgres(process.env.DATABASE_URL!, { prepare: false })\nconst db = drizzle(client, { schema: { errorLogs } })\n\n// Initialize Sentry if DSN is provided\nif (process.env.SENTRY_DSN) {\n  Sentry.init({\n    dsn: process.env.SENTRY_DSN,\n    environment: process.env.NODE_ENV || 'development',\n    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,\n    beforeSend(event) {\n      // Filter out sensitive information\n      if (event.request?.headers) {\n        delete event.request.headers.authorization\n        delete event.request.headers.cookie\n      }\n      return event\n    }\n  })\n}\n\ninterface ErrorContext {\n  userId?: string\n  speechId?: string\n  functionName?: string\n  requestId?: string\n  userAgent?: string\n  ip?: string\n  additionalData?: Record<string, any>\n}\n\ninterface ErrorDetails {\n  message: string\n  stack?: string\n  code?: string\n  statusCode?: number\n  context?: ErrorContext\n}\n\n/**\n * Comprehensive error tracking and logging\n */\nexport async function trackError(error: Error | ErrorDetails, context: ErrorContext = {}) {\n  const errorId = uuidv4()\n  const timestamp = new Date()\n  \n  // Normalize error object\n  const errorDetails = normalizeError(error)\n  \n  // Combine context\n  const fullContext = {\n    ...context,\n    errorId,\n    timestamp: timestamp.toISOString(),\n    environment: process.env.NODE_ENV,\n    service: 'speechwriter-api'\n  }\n  \n  try {\n    // Log to database\n    await logToDatabase(errorDetails, fullContext)\n    \n    // Send to Sentry if configured\n    if (process.env.SENTRY_DSN) {\n      await sendToSentry(errorDetails, fullContext)\n    }\n    \n    // Log to console for development\n    if (process.env.NODE_ENV === 'development') {\n      console.error('Error tracked:', {\n        id: errorId,\n        message: errorDetails.message,\n        context: fullContext\n      })\n    }\n    \n    // Send critical alerts if needed\n    if (isCriticalError(errorDetails)) {\n      await sendCriticalAlert(errorDetails, fullContext)\n    }\n    \n    return errorId\n    \n  } catch (trackingError) {\n    // Fallback logging if error tracking fails\n    console.error('Error tracking failed:', trackingError)\n    console.error('Original error:', errorDetails)\n    return null\n  }\n}\n\n/**\n * Track API errors with request context\n */\nexport async function trackAPIError(\n  error: Error,\n  request: {\n    method?: string\n    url?: string\n    headers?: Record<string, string>\n    body?: any\n  },\n  context: ErrorContext = {}\n) {\n  const apiContext = {\n    ...context,\n    functionName: context.functionName || extractFunctionName(request.url),\n    requestMethod: request.method,\n    requestUrl: request.url,\n    userAgent: request.headers?.['user-agent'],\n    ip: request.headers?.['x-forwarded-for'] || request.headers?.['x-real-ip']\n  }\n  \n  return trackError(error, apiContext)\n}\n\n/**\n * Track user-facing errors with user context\n */\nexport async function trackUserError(\n  error: Error | string,\n  userId: string,\n  action: string,\n  additionalData?: Record<string, any>\n) {\n  const userContext = {\n    userId,\n    action,\n    additionalData: {\n      ...additionalData,\n      userFacing: true\n    }\n  }\n  \n  const errorObj = typeof error === 'string' ? new Error(error) : error\n  return trackError(errorObj, userContext)\n}\n\n/**\n * Track AI service errors\n */\nexport async function trackAIError(\n  error: Error,\n  provider: 'openai' | 'anthropic',\n  model: string,\n  context: ErrorContext = {}\n) {\n  const aiContext = {\n    ...context,\n    additionalData: {\n      ...context.additionalData,\n      aiProvider: provider,\n      aiModel: model,\n      errorType: 'ai_service'\n    }\n  }\n  \n  return trackError(error, aiContext)\n}\n\n/**\n * Normalize error object\n */\nfunction normalizeError(error: Error | ErrorDetails): ErrorDetails {\n  if (error instanceof Error) {\n    return {\n      message: error.message,\n      stack: error.stack,\n      code: (error as any).code,\n      statusCode: (error as any).statusCode\n    }\n  }\n  \n  return error\n}\n\n/**\n * Log error to database\n */\nasync function logToDatabase(error: ErrorDetails, context: ErrorContext) {\n  try {\n    await db.insert(errorLogs).values({\n      id: context.errorId || uuidv4(),\n      userId: context.userId || null,\n      speechId: context.speechId || null,\n      functionName: context.functionName || null,\n      errorMessage: error.message,\n      errorStack: error.stack || null,\n      errorCode: error.code || null,\n      statusCode: error.statusCode || null,\n      requestId: context.requestId || null,\n      userAgent: context.userAgent || null,\n      ipAddress: context.ip || null,\n      context: context.additionalData || null,\n      environment: process.env.NODE_ENV || 'unknown',\n      createdAt: new Date(),\n      resolved: false\n    })\n  } catch (dbError) {\n    console.error('Failed to log error to database:', dbError)\n  }\n}\n\n/**\n * Send error to Sentry\n */\nasync function sendToSentry(error: ErrorDetails, context: ErrorContext) {\n  try {\n    Sentry.withScope(scope => {\n      // Set user context\n      if (context.userId) {\n        scope.setUser({ id: context.userId })\n      }\n      \n      // Set tags\n      scope.setTag('function', context.functionName || 'unknown')\n      scope.setTag('environment', process.env.NODE_ENV || 'unknown')\n      \n      if (context.speechId) {\n        scope.setTag('speechId', context.speechId)\n      }\n      \n      // Set extra context\n      scope.setContext('error_details', {\n        errorId: context.errorId,\n        statusCode: error.statusCode,\n        code: error.code\n      })\n      \n      if (context.additionalData) {\n        scope.setContext('additional_data', context.additionalData)\n      }\n      \n      // Capture the error\n      if (error.stack) {\n        const errorObj = new Error(error.message)\n        errorObj.stack = error.stack\n        Sentry.captureException(errorObj)\n      } else {\n        Sentry.captureMessage(error.message, 'error')\n      }\n    })\n  } catch (sentryError) {\n    console.error('Failed to send error to Sentry:', sentryError)\n  }\n}\n\n/**\n * Check if error is critical and needs immediate attention\n */\nfunction isCriticalError(error: ErrorDetails): boolean {\n  const criticalPatterns = [\n    /database.*connection/i,\n    /payment.*failed/i,\n    /authentication.*failed/i,\n    /rate.*limit.*exceeded/i,\n    /out.*of.*memory/i,\n    /timeout/i\n  ]\n  \n  const criticalCodes = ['ECONNREFUSED', 'ETIMEDOUT', 'ENOTFOUND']\n  const criticalStatusCodes = [500, 502, 503, 504]\n  \n  return (\n    criticalPatterns.some(pattern => pattern.test(error.message)) ||\n    (error.code && criticalCodes.includes(error.code)) ||\n    (error.statusCode && criticalStatusCodes.includes(error.statusCode))\n  )\n}\n\n/**\n * Send critical error alerts\n */\nasync function sendCriticalAlert(error: ErrorDetails, context: ErrorContext) {\n  try {\n    // In production, you might want to send to Slack, email, or other alerting systems\n    if (process.env.SLACK_WEBHOOK_URL) {\n      await sendSlackAlert(error, context)\n    }\n    \n    // Log critical error for immediate attention\n    console.error('ðŸš¨ CRITICAL ERROR DETECTED:', {\n      errorId: context.errorId,\n      message: error.message,\n      function: context.functionName,\n      userId: context.userId,\n      timestamp: context.timestamp\n    })\n    \n  } catch (alertError) {\n    console.error('Failed to send critical alert:', alertError)\n  }\n}\n\n/**\n * Send Slack alert for critical errors\n */\nasync function sendSlackAlert(error: ErrorDetails, context: ErrorContext) {\n  try {\n    const payload = {\n      text: 'ðŸš¨ Critical Error in SpeechWriter API',\n      blocks: [\n        {\n          type: 'section',\n          text: {\n            type: 'mrkdwn',\n            text: `*Critical Error Detected*\\n\\n*Error:* ${error.message}\\n*Function:* ${context.functionName || 'Unknown'}\\n*Environment:* ${process.env.NODE_ENV}\\n*Time:* ${context.timestamp}`\n          }\n        },\n        {\n          type: 'section',\n          fields: [\n            {\n              type: 'mrkdwn',\n              text: `*Error ID:*\\n${context.errorId}`\n            },\n            {\n              type: 'mrkdwn',\n              text: `*User ID:*\\n${context.userId || 'Anonymous'}`\n            }\n          ]\n        }\n      ]\n    }\n    \n    const response = await fetch(process.env.SLACK_WEBHOOK_URL!, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload)\n    })\n    \n    if (!response.ok) {\n      throw new Error(`Slack webhook failed: ${response.status}`)\n    }\n    \n  } catch (slackError) {\n    console.error('Failed to send Slack alert:', slackError)\n  }\n}\n\n/**\n * Extract function name from URL\n */\nfunction extractFunctionName(url?: string): string {\n  if (!url) return 'unknown'\n  \n  const match = url.match(/\\/\\.netlify\\/functions\\/([^?]+)/)\n  return match ? match[1] : 'unknown'\n}\n\n/**\n * Get error statistics for monitoring\n */\nexport async function getErrorStats(timeframe: 'hour' | 'day' | 'week' = 'day') {\n  try {\n    const timeframeDuration = {\n      hour: 1,\n      day: 24,\n      week: 24 * 7\n    }\n    \n    const since = new Date()\n    since.setHours(since.getHours() - timeframeDuration[timeframe])\n    \n    const errors = await db\n      .select()\n      .from(errorLogs)\n      .where(sql`created_at >= ${since}`)\n    \n    const stats = {\n      total: errors.length,\n      critical: errors.filter(e => isCriticalError({ message: e.errorMessage, code: e.errorCode, statusCode: e.statusCode })).length,\n      byFunction: {},\n      byUser: {},\n      resolved: errors.filter(e => e.resolved).length,\n      unresolved: errors.filter(e => !e.resolved).length\n    }\n    \n    // Group by function\n    errors.forEach(error => {\n      const func = error.functionName || 'unknown'\n      stats.byFunction[func] = (stats.byFunction[func] || 0) + 1\n    })\n    \n    // Group by user (for user-specific issues)\n    errors.forEach(error => {\n      if (error.userId) {\n        stats.byUser[error.userId] = (stats.byUser[error.userId] || 0) + 1\n      }\n    })\n    \n    return stats\n    \n  } catch (error) {\n    console.error('Failed to get error stats:', error)\n    return null\n  }\n}\n\n/**\n * Mark error as resolved\n */\nexport async function resolveError(errorId: string, resolvedBy?: string) {\n  try {\n    await db\n      .update(errorLogs)\n      .set({\n        resolved: true,\n        resolvedAt: new Date(),\n        resolvedBy\n      })\n      .where(eq(errorLogs.id, errorId))\n    \n    return true\n  } catch (error) {\n    console.error('Failed to resolve error:', error)\n    return false\n  }\n}\n\n/**\n * Wrapper for async functions to automatically track errors\n */\nexport function withErrorTracking<T extends any[], R>(\n  fn: (...args: T) => Promise<R>,\n  context: Partial<ErrorContext> = {}\n) {\n  return async (...args: T): Promise<R> => {\n    try {\n      return await fn(...args)\n    } catch (error) {\n      await trackError(error as Error, context)\n      throw error\n    }\n  }\n}\n\n// Export Sentry for manual use if needed\nexport { Sentry }"