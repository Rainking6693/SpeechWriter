import { S3Client, GetObjectCommand } from '@aws-sdk/client-s3'\nimport { drizzle } from 'drizzle-orm/postgres-js'\nimport { eq } from 'drizzle-orm'\nimport postgres from 'postgres'\nimport { referenceMaterials } from '@speechwriter/database/schema'\nimport * as pdfParse from 'pdf-parse'\nimport mammoth from 'mammoth'\n\nconst client = postgres(process.env.DATABASE_URL!, { prepare: false })\nconst db = drizzle(client, { schema: { referenceMaterials } })\n\nconst s3Client = new S3Client({\n  region: process.env.S3_REGION || 'us-east-1',\n  endpoint: process.env.S3_ENDPOINT,\n  credentials: {\n    accessKeyId: process.env.S3_ACCESS_KEY_ID!,\n    secretAccessKey: process.env.S3_SECRET_ACCESS_KEY!,\n  },\n})\n\n/**\n * Extract text content from uploaded files\n */\nexport async function extractTextFromFile(fileKey: string, fileType: string): Promise<string> {\n  try {\n    // Download file from S3\n    const getCommand = new GetObjectCommand({\n      Bucket: process.env.S3_BUCKET_NAME!,\n      Key: fileKey\n    })\n\n    const response = await s3Client.send(getCommand)\n    const fileBuffer = await streamToBuffer(response.Body as any)\n\n    let extractedText = ''\n\n    switch (fileType) {\n      case 'application/pdf':\n        const pdfData = await pdfParse(fileBuffer)\n        extractedText = pdfData.text\n        break\n\n      case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':\n        const docxResult = await mammoth.extractRawText({ buffer: fileBuffer })\n        extractedText = docxResult.value\n        break\n\n      case 'text/plain':\n        extractedText = fileBuffer.toString('utf-8')\n        break\n\n      default:\n        throw new Error(`Unsupported file type: ${fileType}`)\n    }\n\n    // Clean up the extracted text\n    extractedText = cleanExtractedText(extractedText)\n\n    return extractedText\n\n  } catch (error) {\n    console.error('Error extracting text from file:', error)\n    throw new Error(`Failed to extract text: ${error.message}`)\n  }\n}\n\n/**\n * Process uploaded file after S3 upload is complete\n */\nexport async function processUploadedFile(referenceMaterialId: string): Promise<void> {\n  try {\n    // Get reference material record\n    const [material] = await db\n      .select()\n      .from(referenceMaterials)\n      .where(eq(referenceMaterials.id, referenceMaterialId))\n      .limit(1)\n\n    if (!material) {\n      throw new Error('Reference material not found')\n    }\n\n    if (material.status !== 'uploading') {\n      console.log(`File ${referenceMaterialId} already processed or failed`)\n      return\n    }\n\n    // Extract text from the file\n    const extractedText = await extractTextFromFile(material.fileKey, material.fileType)\n\n    // Update database with extracted text\n    await db\n      .update(referenceMaterials)\n      .set({\n        extractedText,\n        status: 'processed',\n        updatedAt: new Date()\n      })\n      .where(eq(referenceMaterials.id, referenceMaterialId))\n\n    console.log(`Successfully processed file ${referenceMaterialId}`)\n\n  } catch (error) {\n    console.error('Error processing uploaded file:', error)\n    \n    // Mark as failed\n    await db\n      .update(referenceMaterials)\n      .set({\n        status: 'failed',\n        updatedAt: new Date()\n      })\n      .where(eq(referenceMaterials.id, referenceMaterialId))\n      .catch(dbError => {\n        console.error('Failed to update status to failed:', dbError)\n      })\n\n    throw error\n  }\n}\n\n/**\n * Get extracted text from reference materials for a speech\n */\nexport async function getReferenceMaterialsText(speechId: string): Promise<string> {\n  try {\n    const materials = await db\n      .select()\n      .from(referenceMaterials)\n      .where(eq(referenceMaterials.speechId, speechId))\n\n    const processedMaterials = materials.filter(m => m.status === 'processed' && m.extractedText)\n    \n    if (processedMaterials.length === 0) {\n      return ''\n    }\n\n    // Combine all extracted text with file names as headers\n    const combinedText = processedMaterials\n      .map(m => {\n        const header = `\\n\\n--- Reference Material: ${m.fileName} ---\\n`\n        const description = m.description ? `Description: ${m.description}\\n\\n` : '\\n'\n        return header + description + m.extractedText\n      })\n      .join('\\n\\n')\n\n    return combinedText\n\n  } catch (error) {\n    console.error('Error getting reference materials text:', error)\n    return ''\n  }\n}\n\n/**\n * Clean and normalize extracted text\n */\nfunction cleanExtractedText(text: string): string {\n  return text\n    // Remove excessive whitespace\n    .replace(/\\s+/g, ' ')\n    // Remove excessive line breaks\n    .replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n')\n    // Trim\n    .trim()\n    // Limit length to prevent extremely large texts\n    .substring(0, 50000) // 50k character limit\n}\n\n/**\n * Convert stream to buffer\n */\nfunction streamToBuffer(stream: any): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    const chunks: Buffer[] = []\n    stream.on('data', (chunk: Buffer) => chunks.push(chunk))\n    stream.on('error', reject)\n    stream.on('end', () => resolve(Buffer.concat(chunks)))\n  })\n}\n\n/**\n * Validate file type and size\n */\nexport function validateFile(fileName: string, fileSize: number, fileType: string): { valid: boolean; error?: string } {\n  // Check file size (10MB limit)\n  if (fileSize > 10 * 1024 * 1024) {\n    return { valid: false, error: 'File size must be less than 10MB' }\n  }\n\n  // Check file type\n  const allowedTypes = [\n    'application/pdf',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'text/plain'\n  ]\n\n  if (!allowedTypes.includes(fileType)) {\n    return { valid: false, error: 'File type must be PDF, DOCX, or TXT' }\n  }\n\n  // Check file extension matches MIME type\n  const extension = fileName.split('.').pop()?.toLowerCase()\n  const typeExtensionMap = {\n    'application/pdf': 'pdf',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx',\n    'text/plain': 'txt'\n  }\n\n  if (typeExtensionMap[fileType] !== extension) {\n    return { valid: false, error: 'File extension does not match file type' }\n  }\n\n  return { valid: true }\n}"