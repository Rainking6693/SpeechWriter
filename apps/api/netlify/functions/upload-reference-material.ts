import { Handler, HandlerEvent } from '@netlify/functions'\nimport { z } from 'zod'\nimport { drizzle } from 'drizzle-orm/postgres-js'\nimport { eq } from 'drizzle-orm'\nimport postgres from 'postgres'\nimport { speeches, referenceMaterials } from '@speechwriter/database/schema'\nimport jwt from 'jsonwebtoken'\nimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3'\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'\nimport { v4 as uuidv4 } from 'uuid'\nimport { extractTextFromFile } from './lib/file-processing-utils'\n\nconst client = postgres(process.env.DATABASE_URL!, { prepare: false })\nconst db = drizzle(client, { schema: { speeches, referenceMaterials } })\n\n// Configure S3 client (works with AWS S3 and Cloudflare R2)\nconst s3Client = new S3Client({\n  region: process.env.S3_REGION || 'us-east-1',\n  endpoint: process.env.S3_ENDPOINT, // For Cloudflare R2\n  credentials: {\n    accessKeyId: process.env.S3_ACCESS_KEY_ID!,\n    secretAccessKey: process.env.S3_SECRET_ACCESS_KEY!,\n  },\n})\n\nconst uploadSchema = z.object({\n  speechId: z.string().uuid(),\n  fileName: z.string().min(1).max(255),\n  fileSize: z.number().min(1).max(10 * 1024 * 1024), // 10MB limit\n  fileType: z.string().regex(/^(application\\/pdf|application\\/vnd\\.openxmlformats-officedocument\\.wordprocessingml\\.document|text\\/plain)$/),\n  description: z.string().optional()\n})\n\nconst verifyToken = (token: string) => {\n  try {\n    return jwt.verify(token, process.env.NEXTAUTH_SECRET!)\n  } catch {\n    return null\n  }\n}\n\nconst handler: Handler = async (event: HandlerEvent) => {\n  if (event.httpMethod === 'OPTIONS') {\n    return {\n      statusCode: 200,\n      headers: {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n        'Access-Control-Allow-Methods': 'POST, GET'\n      },\n      body: ''\n    }\n  }\n\n  if (event.httpMethod === 'POST') {\n    try {\n      // Verify authentication\n      const authHeader = event.headers.authorization\n      if (!authHeader?.startsWith('Bearer ')) {\n        return {\n          statusCode: 401,\n          body: JSON.stringify({ error: 'Unauthorized' })\n        }\n      }\n\n      const token = authHeader.replace('Bearer ', '')\n      const decoded = verifyToken(token) as any\n      if (!decoded?.sub) {\n        return {\n          statusCode: 401,\n          body: JSON.stringify({ error: 'Invalid token' })\n        }\n      }\n\n      const userId = decoded.sub\n\n      // Parse and validate request\n      const body = JSON.parse(event.body || '{}')\n      const { speechId, fileName, fileSize, fileType, description } = uploadSchema.parse(body)\n\n      // Verify speech ownership\n      const [speech] = await db\n        .select()\n        .from(speeches)\n        .where(eq(speeches.id, speechId))\n        .limit(1)\n\n      if (!speech || speech.userId !== userId) {\n        return {\n          statusCode: 404,\n          body: JSON.stringify({ error: 'Speech not found' })\n        }\n      }\n\n      // Generate unique file key\n      const fileExtension = fileName.split('.').pop()\n      const fileKey = `reference-materials/${userId}/${speechId}/${uuidv4()}.${fileExtension}`\n\n      // Generate presigned URL for upload\n      const putCommand = new PutObjectCommand({\n        Bucket: process.env.S3_BUCKET_NAME!,\n        Key: fileKey,\n        ContentType: fileType,\n        ContentLength: fileSize,\n        Metadata: {\n          userId,\n          speechId,\n          originalFileName: fileName\n        }\n      })\n\n      const uploadUrl = await getSignedUrl(s3Client, putCommand, { expiresIn: 3600 }) // 1 hour\n\n      // Create database record\n      const [referenceMaterial] = await db\n        .insert(referenceMaterials)\n        .values({\n          id: uuidv4(),\n          speechId,\n          fileName,\n          fileType,\n          fileSize,\n          fileKey,\n          description: description || null,\n          status: 'uploading',\n          extractedText: null,\n          createdAt: new Date(),\n          updatedAt: new Date()\n        })\n        .returning()\n\n      return {\n        statusCode: 200,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          uploadUrl,\n          referenceMaterialId: referenceMaterial.id,\n          fileKey,\n          message: 'Upload URL generated successfully'\n        })\n      }\n\n    } catch (error) {\n      console.error('Error generating upload URL:', error)\n      return {\n        statusCode: 500,\n        body: JSON.stringify({ \n          error: 'Failed to generate upload URL',\n          details: process.env.NODE_ENV === 'development' ? error.message : undefined\n        })\n      }\n    }\n  }\n\n  if (event.httpMethod === 'GET') {\n    try {\n      // Get reference materials for a speech\n      const authHeader = event.headers.authorization\n      if (!authHeader?.startsWith('Bearer ')) {\n        return {\n          statusCode: 401,\n          body: JSON.stringify({ error: 'Unauthorized' })\n        }\n      }\n\n      const token = authHeader.replace('Bearer ', '')\n      const decoded = verifyToken(token) as any\n      if (!decoded?.sub) {\n        return {\n          statusCode: 401,\n          body: JSON.stringify({ error: 'Invalid token' })\n        }\n      }\n\n      const userId = decoded.sub\n      const speechId = event.queryStringParameters?.speechId\n\n      if (!speechId) {\n        return {\n          statusCode: 400,\n          body: JSON.stringify({ error: 'speechId parameter required' })\n        }\n      }\n\n      // Verify speech ownership\n      const [speech] = await db\n        .select()\n        .from(speeches)\n        .where(eq(speeches.id, speechId))\n        .limit(1)\n\n      if (!speech || speech.userId !== userId) {\n        return {\n          statusCode: 404,\n          body: JSON.stringify({ error: 'Speech not found' })\n        }\n      }\n\n      // Get reference materials\n      const materials = await db\n        .select()\n        .from(referenceMaterials)\n        .where(eq(referenceMaterials.speechId, speechId))\n\n      return {\n        statusCode: 200,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          materials: materials.map(m => ({\n            id: m.id,\n            fileName: m.fileName,\n            fileType: m.fileType,\n            fileSize: m.fileSize,\n            description: m.description,\n            status: m.status,\n            hasExtractedText: !!m.extractedText,\n            createdAt: m.createdAt,\n            updatedAt: m.updatedAt\n          }))\n        })\n      }\n\n    } catch (error) {\n      console.error('Error fetching reference materials:', error)\n      return {\n        statusCode: 500,\n        body: JSON.stringify({ \n          error: 'Failed to fetch reference materials',\n          details: process.env.NODE_ENV === 'development' ? error.message : undefined\n        })\n      }\n    }\n  }\n\n  return {\n    statusCode: 405,\n    body: JSON.stringify({ error: 'Method not allowed' })\n  }\n}\n\nexport { handler }"