import { Handler, HandlerEvent, HandlerContext } from '@netlify/functions';
import { z } from 'zod';
import puppeteer from 'puppeteer';
import type { ApiResponse } from '@speechwriter/config';

// Request validation schema
const exportPdfSchema = z.object({
  speechId: z.string().uuid(),
  format: z.enum(['speaker-notes', 'full-script', 'outline-only']).default('full-script'),
  includeStageDirections: z.boolean().default(true),
  includeTiming: z.boolean().default(true),
  watermark: z.boolean().default(false), // Will be set based on subscription plan
});

// PDF generation using Puppeteer
const generatePDF = async (htmlContent: string, options: any): Promise<Buffer> => {
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  
  try {
    const page = await browser.newPage();
    await page.setContent(htmlContent, { waitUntil: 'networkidle0' });
    
    const pdfBuffer = await page.pdf({
      format: 'A4',
      printBackground: true,
      margin: {
        top: '1in',
        right: '0.75in',
        bottom: '1in',
        left: '0.75in'
      },
      ...options
    });
    
    return pdfBuffer as Buffer;
  } finally {
    await browser.close();
  }
};

// Generate HTML template for PDF
const generateSpeechHTML = (speech: any, options: any): string => {
  const { format, includeStageDirections, includeTiming, watermark } = options;
  
  // Format stage directions like [PAUSE], [EMPHASIZE], [CALLBACK]
  const formatStageDirections = (text: string): string => {
    if (!includeStageDirections) {
      return text.replace(/\[([A-Z]+)\]/g, '');
    }
    
    return text.replace(/\[([A-Z]+)\]/g, '<span class="stage-direction">[$1]</span>');
  };
  
  // Format timing information
  const formatTiming = (section: any): string => {
    if (!includeTiming) return '';
    const allocated = section.allocatedTimeMinutes || 0;
    const actual = section.actualTimeMinutes || 0;
    return `<div class="timing">Target: ${allocated}min${actual ? ` | Actual: ${actual}min` : ''}</div>`;
  };
  
  const watermarkHTML = watermark ? `
    <div class="watermark">
      <div class="watermark-text">
        Generated by SpeechWriter.ai - Free Plan<br>
        Upgrade for clean exports
      </div>
    </div>
  ` : '';
  
  const sectionsHTML = speech.sections?.map((section: any, index: number) => `
    <div class="section">
      <h2 class="section-title">${section.title}</h2>
      ${formatTiming(section)}
      <div class="section-content">
        ${formatStageDirections(section.content || '')}
      </div>
    </div>
  `).join('') || '';
  
  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${speech.title}</title>
      <style>
        body {
          font-family: 'Georgia', 'Times New Roman', serif;
          line-height: 1.6;
          color: #333;
          max-width: 8.5in;
          margin: 0 auto;
          padding: 0;
          position: relative;
        }
        
        .header {
          text-align: center;
          margin-bottom: 2rem;
          border-bottom: 2px solid #333;
          padding-bottom: 1rem;
        }
        
        .speech-title {
          font-size: 2rem;
          font-weight: bold;
          margin: 0;
          color: #2c3e50;
        }
        
        .speech-meta {
          font-size: 1rem;
          color: #666;
          margin-top: 0.5rem;
        }
        
        .section {
          margin-bottom: 2rem;
          page-break-inside: avoid;
        }
        
        .section-title {
          font-size: 1.3rem;
          font-weight: bold;
          color: #2c3e50;
          border-left: 4px solid #3498db;
          padding-left: 1rem;
          margin-bottom: 0.5rem;
        }
        
        .timing {
          font-size: 0.9rem;
          color: #7f8c8d;
          margin-bottom: 1rem;
          font-style: italic;
        }
        
        .section-content {
          font-size: 1.1rem;
          line-height: 1.8;
          text-align: justify;
        }
        
        .stage-direction {
          color: #e74c3c;
          font-weight: bold;
          font-family: 'Arial', sans-serif;
          font-size: 0.9em;
          text-transform: uppercase;
        }
        
        .watermark {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%) rotate(-45deg);
          z-index: -1;
          opacity: 0.1;
        }
        
        .watermark-text {
          font-size: 2rem;
          font-weight: bold;
          color: #999;
          text-align: center;
          white-space: nowrap;
        }
        
        .footer {
          margin-top: 3rem;
          padding-top: 1rem;
          border-top: 1px solid #ddd;
          font-size: 0.9rem;
          color: #666;
          text-align: center;
        }
        
        @media print {
          body {
            margin: 0;
            padding: 1rem;
          }
          
          .section {
            page-break-inside: avoid;
          }
        }
      </style>
    </head>
    <body>
      ${watermarkHTML}
      
      <div class="header">
        <h1 class="speech-title">${speech.title}</h1>
        <div class="speech-meta">
          <strong>Occasion:</strong> ${speech.occasion}<br>
          <strong>Audience:</strong> ${speech.audience}<br>
          <strong>Target Duration:</strong> ${speech.targetDurationMinutes} minutes
        </div>
      </div>
      
      <div class="content">
        ${sectionsHTML}
      </div>
      
      <div class="footer">
        Generated on ${new Date().toLocaleDateString()} | SpeechWriter.ai
      </div>
    </body>
    </html>
  `;
};

const handler: Handler = async (event: HandlerEvent, context: HandlerContext) => {
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  };

  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers,
      body: '',
    };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({
        success: false,
        error: {
          message: 'Method not allowed',
          code: 'METHOD_NOT_ALLOWED',
        },
        timestamp: new Date().toISOString(),
      } as ApiResponse),
    };
  }

  try {
    // TODO: Add authentication check
    // const authToken = event.headers.authorization?.replace('Bearer ', '');
    // const user = await validateToken(authToken);
    
    // Parse and validate request body
    const body = JSON.parse(event.body || '{}');
    const validatedData = exportPdfSchema.parse(body);

    // TODO: Fetch speech data from database
    // const speech = await getSpeechWithSections(validatedData.speechId, user.id);
    
    // Mock speech data for now
    const mockSpeech = {
      id: validatedData.speechId,
      title: "Sample Keynote Speech",
      occasion: "Tech Conference 2025",
      audience: "Software developers and tech leaders",
      targetDurationMinutes: 15,
      sections: [
        {
          id: "1",
          title: "Opening Hook",
          content: "[PAUSE] Good morning, innovators and builders! [EMPHASIZE] Today, we're not just talking about the future of technology – we're living it.",
          allocatedTimeMinutes: 2,
          actualTimeMinutes: 2
        },
        {
          id: "2", 
          title: "Main Content",
          content: "The digital transformation isn't coming – it's here. [CALLBACK] Remember when we thought AI was science fiction? [PAUSE] Well, it's now writing our code, designing our interfaces, and revolutionizing how we solve problems.",
          allocatedTimeMinutes: 11,
          actualTimeMinutes: 10
        },
        {
          id: "3",
          title: "Call to Action",
          content: "[EMPHASIZE] The question isn't whether you'll adapt to this new reality – it's how quickly you'll embrace it. [PAUSE] The future belongs to those who build it. Let's build it together.",
          allocatedTimeMinutes: 2,
          actualTimeMinutes: 3
        }
      ]
    };

    // TODO: Check user subscription level and set watermark accordingly
    // const subscription = await getUserSubscription(user.id);
    // const shouldWatermark = subscription.plan === 'free';
    const shouldWatermark = validatedData.watermark;

    // Generate HTML content
    const htmlContent = generateSpeechHTML(mockSpeech, {
      ...validatedData,
      watermark: shouldWatermark
    });

    // Generate PDF
    const pdfBuffer = await generatePDF(htmlContent, {
      displayHeaderFooter: true,
      headerTemplate: '<div></div>',
      footerTemplate: '<div style="font-size: 10px; text-align: center; width: 100%;">Page <span class="pageNumber"></span> of <span class="totalPages"></span></div>'
    });

    // Return PDF as base64
    const base64Pdf = pdfBuffer.toString('base64');
    
    return {
      statusCode: 200,
      headers: {
        ...headers,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        success: true,
        data: {
          filename: `${mockSpeech.title.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`,
          content: base64Pdf,
          size: pdfBuffer.length,
          format: validatedData.format
        },
        timestamp: new Date().toISOString(),
      } as ApiResponse),
    };
  } catch (error) {
    console.error('Error generating PDF:', error);

    const errorResponse: ApiResponse = {
      success: false,
      error: {
        message: error instanceof Error ? error.message : 'PDF generation failed',
        code: 'PDF_GENERATION_ERROR',
        details: error instanceof z.ZodError ? error.errors : undefined,
      },
      timestamp: new Date().toISOString(),
    };

    return {
      statusCode: error instanceof z.ZodError ? 400 : 500,
      headers,
      body: JSON.stringify(errorResponse),
    };
  }
};

export { handler };