import { Handler, HandlerEvent, HandlerContext } from '@netlify/functions';
import { z } from 'zod';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, BorderStyle } from 'docx';
import type { ApiResponse } from '@speechwriter/config';

// Request validation schema
const exportDocxSchema = z.object({
  speechId: z.string().uuid(),
  format: z.enum(['speaker-notes', 'full-script', 'outline-only']).default('full-script'),
  includeStageDirections: z.boolean().default(true),
  includeTiming: z.boolean().default(true),
  watermark: z.boolean().default(false), // Will be set based on subscription plan
});

// Generate DOCX document
const generateDocx = async (speech: any, options: any): Promise<Buffer> => {
  const { format, includeStageDirections, includeTiming, watermark } = options;
  
  // Format stage directions
  const formatStageDirections = (text: string): TextRun[] => {
    if (!includeStageDirections) {
      text = text.replace(/\[([A-Z]+)\]/g, '');
    }
    
    const parts = text.split(/(\[[A-Z]+\])/g);
    return parts.map(part => {
      if (part.match(/^\[[A-Z]+\]$/)) {
        return new TextRun({
          text: part,
          bold: true,
          color: "DC3545", // Red color for stage directions
          italics: true
        });
      }
      return new TextRun(part);
    });
  };

  // Document sections
  const docSections = [];
  
  // Title page
  docSections.push(
    new Paragraph({
      text: speech.title,
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 }
    }),
    new Paragraph({
      children: [
        new TextRun({
          text: `Occasion: ${speech.occasion}`,
          bold: true
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 200 }
    }),
    new Paragraph({
      children: [
        new TextRun({
          text: `Audience: ${speech.audience}`,
          bold: true
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 200 }
    }),
    new Paragraph({
      children: [
        new TextRun({
          text: `Target Duration: ${speech.targetDurationMinutes} minutes`,
          bold: true
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 }
    })
  );
  
  // Watermark for free users
  if (watermark) {
    docSections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: "Generated by SpeechWriter.ai - Free Plan",
            color: "999999",
            italics: true,
            size: 20
          })
        ],
        alignment: AlignmentType.CENTER,
        spacing: { after: 300 }
      }),
      new Paragraph({
        children: [
          new TextRun({
            text: "Upgrade for clean exports and advanced features",
            color: "999999",
            italics: true,
            size: 20
          })
        ],
        alignment: AlignmentType.CENTER,
        spacing: { after: 600 }
      })
    );
  }
  
  // Page break before content
  docSections.push(
    new Paragraph({
      text: "",
      pageBreakBefore: true
    })
  );

  // Speech content sections
  speech.sections?.forEach((section: any, index: number) => {
    // Section title
    docSections.push(
      new Paragraph({
        text: section.title,
        heading: HeadingLevel.HEADING_1,
        spacing: { before: 400, after: 200 }
      })
    );
    
    // Timing information
    if (includeTiming) {
      const allocated = section.allocatedTimeMinutes || 0;
      const actual = section.actualTimeMinutes || 0;
      const timingText = `Target: ${allocated}min${actual ? ` | Actual: ${actual}min` : ''}`;
      
      docSections.push(
        new Paragraph({
          children: [
            new TextRun({
              text: timingText,
              italics: true,
              color: "666666",
              size: 20
            })
          ],
          spacing: { after: 200 }
        })
      );
    }
    
    // Section content
    if (section.content) {
      const contentRuns = formatStageDirections(section.content);
      docSections.push(
        new Paragraph({
          children: contentRuns,
          spacing: { after: 300, line: 360 }, // 1.5 line spacing
          alignment: AlignmentType.JUSTIFIED
        })
      );
    }
    
    // Add some space between sections
    if (index < speech.sections.length - 1) {
      docSections.push(
        new Paragraph({
          text: "",
          spacing: { after: 400 }
        })
      );
    }
  });
  
  // Footer
  docSections.push(
    new Paragraph({
      text: "",
      spacing: { before: 800 }
    }),
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated on ${new Date().toLocaleDateString()} | SpeechWriter.ai`,
          color: "666666",
          size: 18
        })
      ],
      alignment: AlignmentType.CENTER,
      border: {
        top: {
          color: "CCCCCC",
          size: 1,
          style: BorderStyle.SINGLE,
          space: 8
        }
      }
    })
  );

  // Create document
  const doc = new Document({
    sections: [{
      properties: {},
      children: docSections
    }]
  });

  // Generate buffer
  const buffer = await Packer.toBuffer(doc);
  return buffer;
};

const handler: Handler = async (event: HandlerEvent, context: HandlerContext) => {
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  };

  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers,
      body: '',
    };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({
        success: false,
        error: {
          message: 'Method not allowed',
          code: 'METHOD_NOT_ALLOWED',
        },
        timestamp: new Date().toISOString(),
      } as ApiResponse),
    };
  }

  try {
    // TODO: Add authentication check
    // const authToken = event.headers.authorization?.replace('Bearer ', '');
    // const user = await validateToken(authToken);
    
    // Parse and validate request body
    const body = JSON.parse(event.body || '{}');
    const validatedData = exportDocxSchema.parse(body);

    // TODO: Fetch speech data from database
    // const speech = await getSpeechWithSections(validatedData.speechId, user.id);
    
    // Mock speech data for now
    const mockSpeech = {
      id: validatedData.speechId,
      title: "Sample Keynote Speech",
      occasion: "Tech Conference 2025",
      audience: "Software developers and tech leaders",
      targetDurationMinutes: 15,
      sections: [
        {
          id: "1",
          title: "Opening Hook",
          content: "[PAUSE] Good morning, innovators and builders! [EMPHASIZE] Today, we're not just talking about the future of technology – we're living it. Welcome to a world where artificial intelligence doesn't just assist us – it collaborates with us, learns from us, and helps us reach heights we never thought possible.",
          allocatedTimeMinutes: 2,
          actualTimeMinutes: 2
        },
        {
          id: "2", 
          title: "Main Content - The AI Revolution",
          content: "The digital transformation isn't coming – it's here. [CALLBACK] Remember when we thought AI was science fiction? [PAUSE] Well, it's now writing our code, designing our interfaces, and revolutionizing how we solve problems. But here's the thing that excites me most: we're just getting started. Every line of code we write, every algorithm we optimize, every user experience we craft – it's all building toward something bigger. We're not just developers anymore. We're architects of the future.",
          allocatedTimeMinutes: 11,
          actualTimeMinutes: 10
        },
        {
          id: "3",
          title: "Call to Action",
          content: "[EMPHASIZE] The question isn't whether you'll adapt to this new reality – it's how quickly you'll embrace it. [PAUSE] The future belongs to those who build it. The innovators. The problem solvers. The ones who see obstacles as opportunities. [CALLBACK] So let's not just talk about the future of technology – let's build it together. Thank you.",
          allocatedTimeMinutes: 2,
          actualTimeMinutes: 3
        }
      ]
    };

    // TODO: Check user subscription level and set watermark accordingly
    // const subscription = await getUserSubscription(user.id);
    // const shouldWatermark = subscription.plan === 'free';
    const shouldWatermark = validatedData.watermark;

    // Generate DOCX
    const docxBuffer = await generateDocx(mockSpeech, {
      ...validatedData,
      watermark: shouldWatermark
    });

    // Return DOCX as base64
    const base64Docx = docxBuffer.toString('base64');
    
    return {
      statusCode: 200,
      headers: {
        ...headers,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        success: true,
        data: {
          filename: `${mockSpeech.title.replace(/[^a-zA-Z0-9]/g, '_')}.docx`,
          content: base64Docx,
          size: docxBuffer.length,
          format: validatedData.format
        },
        timestamp: new Date().toISOString(),
      } as ApiResponse),
    };
  } catch (error) {
    console.error('Error generating DOCX:', error);

    const errorResponse: ApiResponse = {
      success: false,
      error: {
        message: error instanceof Error ? error.message : 'DOCX generation failed',
        code: 'DOCX_GENERATION_ERROR',
        details: error instanceof z.ZodError ? error.errors : undefined,
      },
      timestamp: new Date().toISOString(),
    };

    return {
      statusCode: error instanceof z.ZodError ? 400 : 500,
      headers,
      body: JSON.stringify(errorResponse),
    };
  }
};

export { handler };